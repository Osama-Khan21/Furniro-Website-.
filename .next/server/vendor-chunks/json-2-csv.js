"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/json-2-csv";
exports.ids = ["vendor-chunks/json-2-csv"];
exports.modules = {

/***/ "(ssr)/./node_modules/json-2-csv/lib/constants.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/constants.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;\nexports.errors = {\n    optionsRequired: 'Options were not passed and are required.',\n    json2csv: {\n        cannotCallOn: 'Cannot call json2csv on',\n        dataCheckFailure: 'Data provided was not an array of documents.',\n        notSameSchema: 'Not all documents have the same schema.'\n    },\n    csv2json: {\n        cannotCallOn: 'Cannot call csv2json on',\n        dataCheckFailure: 'CSV is not a string.'\n    }\n};\nexports.defaultJson2CsvOptions = {\n    arrayIndexesAsKeys: false,\n    checkSchemaDifferences: false,\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    emptyFieldValue: undefined,\n    escapeHeaderNestedDots: true,\n    excelBOM: false,\n    excludeKeys: [],\n    expandNestedObjects: true,\n    expandArrayObjects: false,\n    prependHeader: true,\n    preventCsvInjection: false,\n    sortHeader: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n    unwindArrays: false,\n    useDateIso8601Format: false,\n    useLocaleFormat: false,\n    wrapBooleans: false,\n};\nexports.defaultCsv2JsonOptions = {\n    delimiter: {\n        field: ',',\n        wrap: '\"',\n        eol: '\\n'\n    },\n    excelBOM: false,\n    preventCsvInjection: false,\n    trimFieldValues: false,\n    trimHeaderFields: false,\n};\nexports.excelBOM = '\\ufeff';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLDhCQUE4QixHQUFHLDhCQUE4QixHQUFHLGNBQWM7QUFDbkcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGUvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29uc3RhbnRzLmpzPzdlNTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leGNlbEJPTSA9IGV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyA9IGV4cG9ydHMuZXJyb3JzID0gdm9pZCAwO1xuZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgb3B0aW9uc1JlcXVpcmVkOiAnT3B0aW9ucyB3ZXJlIG5vdCBwYXNzZWQgYW5kIGFyZSByZXF1aXJlZC4nLFxuICAgIGpzb24yY3N2OiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGpzb24yY3N2IG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0RhdGEgcHJvdmlkZWQgd2FzIG5vdCBhbiBhcnJheSBvZiBkb2N1bWVudHMuJyxcbiAgICAgICAgbm90U2FtZVNjaGVtYTogJ05vdCBhbGwgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgc2NoZW1hLidcbiAgICB9LFxuICAgIGNzdjJqc29uOiB7XG4gICAgICAgIGNhbm5vdENhbGxPbjogJ0Nhbm5vdCBjYWxsIGNzdjJqc29uIG9uJyxcbiAgICAgICAgZGF0YUNoZWNrRmFpbHVyZTogJ0NTViBpcyBub3QgYSBzdHJpbmcuJ1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHRKc29uMkNzdk9wdGlvbnMgPSB7XG4gICAgYXJyYXlJbmRleGVzQXNLZXlzOiBmYWxzZSxcbiAgICBjaGVja1NjaGVtYURpZmZlcmVuY2VzOiBmYWxzZSxcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZW1wdHlGaWVsZFZhbHVlOiB1bmRlZmluZWQsXG4gICAgZXNjYXBlSGVhZGVyTmVzdGVkRG90czogdHJ1ZSxcbiAgICBleGNlbEJPTTogZmFsc2UsXG4gICAgZXhjbHVkZUtleXM6IFtdLFxuICAgIGV4cGFuZE5lc3RlZE9iamVjdHM6IHRydWUsXG4gICAgZXhwYW5kQXJyYXlPYmplY3RzOiBmYWxzZSxcbiAgICBwcmVwZW5kSGVhZGVyOiB0cnVlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHNvcnRIZWFkZXI6IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG4gICAgdW53aW5kQXJyYXlzOiBmYWxzZSxcbiAgICB1c2VEYXRlSXNvODYwMUZvcm1hdDogZmFsc2UsXG4gICAgdXNlTG9jYWxlRm9ybWF0OiBmYWxzZSxcbiAgICB3cmFwQm9vbGVhbnM6IGZhbHNlLFxufTtcbmV4cG9ydHMuZGVmYXVsdENzdjJKc29uT3B0aW9ucyA9IHtcbiAgICBkZWxpbWl0ZXI6IHtcbiAgICAgICAgZmllbGQ6ICcsJyxcbiAgICAgICAgd3JhcDogJ1wiJyxcbiAgICAgICAgZW9sOiAnXFxuJ1xuICAgIH0sXG4gICAgZXhjZWxCT006IGZhbHNlLFxuICAgIHByZXZlbnRDc3ZJbmplY3Rpb246IGZhbHNlLFxuICAgIHRyaW1GaWVsZFZhbHVlczogZmFsc2UsXG4gICAgdHJpbUhlYWRlckZpZWxkczogZmFsc2UsXG59O1xuZXhwb3J0cy5leGNlbEJPTSA9ICdcXHVmZWZmJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/converter.js":
/*!**************************************************!*\
  !*** ./node_modules/json-2-csv/lib/converter.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.csv2json = exports.json2csv = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst json2csv_1 = __webpack_require__(/*! ./json2csv */ \"(ssr)/./node_modules/json-2-csv/lib/json2csv.js\");\nconst csv2json_1 = __webpack_require__(/*! ./csv2json */ \"(ssr)/./node_modules/json-2-csv/lib/csv2json.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\");\nfunction json2csv(data, options) {\n    const builtOptions = (0, utils_1.buildJ2COptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);\n    return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);\n}\nexports.json2csv = json2csv;\nfunction csv2json(data, options) {\n    const builtOptions = (0, utils_1.buildC2JOptions)(options ?? {});\n    // Validate the parameters before calling the converter's convert function\n    (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);\n    return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);\n}\nexports.csv2json = csv2json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQjtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBUztBQUNqQztBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpdGUvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY29udmVydGVyLmpzP2VmYzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jc3YyanNvbiA9IGV4cG9ydHMuanNvbjJjc3YgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGpzb24yY3N2XzEgPSByZXF1aXJlKFwiLi9qc29uMmNzdlwiKTtcbmNvbnN0IGNzdjJqc29uXzEgPSByZXF1aXJlKFwiLi9jc3YyanNvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGpzb24yY3N2KGRhdGEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsdE9wdGlvbnMgPSAoMCwgdXRpbHNfMS5idWlsZEoyQ09wdGlvbnMpKG9wdGlvbnMgPz8ge30pO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXJzIGJlZm9yZSBjYWxsaW5nIHRoZSBjb252ZXJ0ZXIncyBjb252ZXJ0IGZ1bmN0aW9uXG4gICAgKDAsIHV0aWxzXzEudmFsaWRhdGUpKGRhdGEsIHV0aWxzXzEuaXNPYmplY3QsIGNvbnN0YW50c18xLmVycm9ycy5qc29uMmNzdik7XG4gICAgcmV0dXJuICgwLCBqc29uMmNzdl8xLkpzb24yQ3N2KShidWlsdE9wdGlvbnMpLmNvbnZlcnQoZGF0YSk7XG59XG5leHBvcnRzLmpzb24yY3N2ID0ganNvbjJjc3Y7XG5mdW5jdGlvbiBjc3YyanNvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVpbHRPcHRpb25zID0gKDAsIHV0aWxzXzEuYnVpbGRDMkpPcHRpb25zKShvcHRpb25zID8/IHt9KTtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVycyBiZWZvcmUgY2FsbGluZyB0aGUgY29udmVydGVyJ3MgY29udmVydCBmdW5jdGlvblxuICAgICgwLCB1dGlsc18xLnZhbGlkYXRlKShkYXRhLCB1dGlsc18xLmlzU3RyaW5nLCBjb25zdGFudHNfMS5lcnJvcnMuY3N2Mmpzb24pO1xuICAgIHJldHVybiAoMCwgY3N2Mmpzb25fMS5Dc3YySnNvbikoYnVpbHRPcHRpb25zKS5jb252ZXJ0KGRhdGEpO1xufVxuZXhwb3J0cy5jc3YyanNvbiA9IGNzdjJqc29uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/csv2json.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/csv2json.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Csv2Json = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Csv2Json = function (options) {\n    const escapedWrapDelimiterRegex = new RegExp(options.delimiter.wrap + options.delimiter.wrap, 'g'), excelBOMRegex = new RegExp('^' + constants_1.excelBOM), valueParserFn = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : JSON.parse;\n    /**\n     * Trims the header key, if specified by the user via the provided options\n     */\n    function processHeaderKey(headerKey) {\n        headerKey = removeWrapDelimitersFromValue(headerKey);\n        if (options.trimHeaderFields) {\n            return headerKey.split('.')\n                .map((component) => component.trim())\n                .join('.');\n        }\n        return headerKey;\n    }\n    /**\n     * Generate the JSON heading from the CSV\n     */\n    function retrieveHeading(lines) {\n        let headerFields = [];\n        if (options.headerFields) {\n            headerFields = options.headerFields.map((headerField, index) => ({\n                value: processHeaderKey(headerField),\n                index\n            }));\n        }\n        else {\n            // Generate and return the heading keys\n            const headerRow = lines[0];\n            headerFields = headerRow.map((headerKey, index) => ({\n                value: processHeaderKey(headerKey),\n                index\n            }));\n            // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n            if (options.keys) {\n                const keys = options.keys; // TypeScript type checking work around to get it to recognize the option is not undefined\n                headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));\n            }\n        }\n        return {\n            lines,\n            headerFields,\n            recordLines: [],\n        };\n    }\n    /**\n     * Removes the Excel BOM value, if specified by the options object\n     */\n    function stripExcelBOM(csv) {\n        if (options.excelBOM) {\n            return csv.replace(excelBOMRegex, '');\n        }\n        return csv;\n    }\n    /**\n     * Helper function that splits a line so that we can handle wrapped fields\n     */\n    function splitLines(csv) {\n        // Parse out the line...\n        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options.delimiter.eol.length, stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            justParsedDoubleQuote: false,\n            startIndex: 0\n        };\n        let splitLine = [], character, charBefore, charAfter, nextNChar, index = 0;\n        // Loop through each character in the line to identify where to split the values\n        while (index < csv.length) {\n            // Current character\n            character = csv[index];\n            // Previous character\n            charBefore = index ? csv[index - 1] : '';\n            // Next character\n            charAfter = index < lastCharacterIndex ? csv[index + 1] : '';\n            // Next n characters, including the current character, where n = length(EOL delimiter)\n            // This allows for the checking of an EOL delimiter when if it is more than a single character (eg. '\\r\\n')\n            nextNChar = utils.getNCharacters(csv, index, eolDelimiterLength);\n            if ((nextNChar === options.delimiter.eol && !stateVariables.insideWrapDelimiter ||\n                index === lastCharacterIndex) && charBefore === options.delimiter.field) {\n                // If we reached an EOL delimiter or the end of the csv and the previous character is a field delimiter...\n                // If the start index is the current index (and since the previous character is a comma),\n                //   then the value being parsed is an empty value accordingly, add an empty string\n                if (nextNChar === options.delimiter.eol && stateVariables.startIndex === index) {\n                    splitLine.push('');\n                }\n                else if (character === options.delimiter.field) {\n                    // If we reached the end of the CSV, there's no new line, and the current character is a comma\n                    // then add an empty string for the current value\n                    splitLine.push('');\n                }\n                else {\n                    // Otherwise, there's a valid value, and the start index isn't the current index, grab the whole value\n                    splitLine.push(csv.substring(stateVariables.startIndex));\n                }\n                // Since the last character is a comma, there's still an additional implied field value trailing the comma.\n                //   Since this value is empty, we push an extra empty value\n                splitLine.push('');\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (index === lastCharacterIndex && character === options.delimiter.field) {\n                // If we reach the end of the CSV and the current character is a field delimiter\n                // Parse the previously seen value and add it to the line\n                const parsedValue = csv.substring(stateVariables.startIndex, index);\n                splitLine.push(parsedValue);\n                // Then add an empty string to the line since the last character being a field delimiter indicates an empty field\n                splitLine.push('');\n                lines.push(splitLine);\n            }\n            else if (index === lastCharacterIndex || nextNChar === options.delimiter.eol &&\n                // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two\n                (!stateVariables.insideWrapDelimiter ||\n                    stateVariables.insideWrapDelimiter && charBefore === options.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {\n                // Otherwise if we reached the end of the line or csv (and current character is not a field delimiter)\n                const toIndex = index !== lastCharacterIndex || charBefore === options.delimiter.wrap ? index : undefined;\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, toIndex));\n                // Finally, push the split line values into the lines array and clear the split line\n                lines.push(splitLine);\n                splitLine = [];\n                stateVariables.startIndex = index + eolDelimiterLength;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = charAfter === options.delimiter.wrap;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {\n                // If we reached a wrap delimiter after a comma and we aren't inside a wrap delimiter\n                stateVariables.startIndex = index;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                // If the next character(s) are an EOL delimiter, then skip them so we don't parse what we've seen as another value\n                if (utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                    index += options.delimiter.eol.length + 1; // Skip past EOL\n                }\n            }\n            else if (charBefore === options.delimiter.field && character === options.delimiter.wrap && charAfter === options.delimiter.eol) {\n                // We reached the start of a wrapped new field that begins with an EOL delimiter\n                // Retrieve the remaining value and add it to the split line list of values\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.startIndex = index;\n                stateVariables.parsingValue = true;\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.justParsedDoubleQuote = true;\n                index += 1;\n            }\n            else if ((charBefore !== options.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options.delimiter.wrap) &&\n                character === options.delimiter.wrap && utils.getNCharacters(csv, index + 1, eolDelimiterLength) === options.delimiter.eol) {\n                // If we reach a wrap which is not preceded by a wrap delim and the next character is an EOL delim (ie. *\"\\n)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n                // Next iteration will substring, add the value to the line, and push the line onto the array of lines\n            }\n            else if (character === options.delimiter.wrap && (index === 0 || utils.getNCharacters(csv, index - eolDelimiterLength, eolDelimiterLength) === options.delimiter.eol && !stateVariables.insideWrapDelimiter)) {\n                // If the line starts with a wrap delimiter (ie. \"*)\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.field) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n                splitLine.push(csv.substring(stateVariables.startIndex, index + 1));\n                stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = false;\n            }\n            else if (character === options.delimiter.wrap && charBefore === options.delimiter.field &&\n                !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {\n                // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index - 1));\n                stateVariables.insideWrapDelimiter = true;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index;\n            }\n            else if (character === options.delimiter.wrap && charAfter === options.delimiter.wrap && index !== stateVariables.startIndex) {\n                // If we run into an escaped quote (ie. \"\") skip past the second quote\n                index += 2;\n                stateVariables.justParsedDoubleQuote = true;\n                continue;\n            }\n            else if (character === options.delimiter.field && charBefore !== options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.insideWrapDelimiter &&\n                stateVariables.parsingValue) {\n                // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n                splitLine.push(csv.substring(stateVariables.startIndex, index));\n                stateVariables.startIndex = index + 1;\n            }\n            else if (character === options.delimiter.field && charBefore === options.delimiter.wrap &&\n                charAfter !== options.delimiter.wrap && !stateVariables.parsingValue) {\n                // If we reached a field delimiter, the previous character was a wrap delimiter, and the\n                //   next character is not a wrap delimiter (ie. \",*)\n                stateVariables.insideWrapDelimiter = false;\n                stateVariables.parsingValue = true;\n                stateVariables.startIndex = index + 1;\n            }\n            // Otherwise increment to the next character\n            index++;\n            // Reset the double quote state variable\n            stateVariables.justParsedDoubleQuote = false;\n        }\n        return lines;\n    }\n    /**\n     * Retrieves the record lines from the split CSV lines and sets it on the params object\n     */\n    function retrieveRecordLines(params) {\n        if (options.headerFields) { // This option is passed for instances where the CSV has no header line\n            params.recordLines = params.lines;\n        }\n        else { // All lines except for the header line\n            params.recordLines = params.lines.splice(1);\n        }\n        return params;\n    }\n    /**\n     * Retrieves the value for the record from the line at the provided key.\n     */\n    function retrieveRecordValueFromLine(headerField, line) {\n        // If there is a value at the key's index, use it; otherwise, null\n        const value = line[headerField.index];\n        // Perform any necessary value conversions on the record value\n        return processRecordValue(value);\n    }\n    /**\n     * Processes the record's value by parsing the data to ensure the CSV is\n     * converted to the JSON that created it.\n     */\n    function processRecordValue(fieldValue) {\n        // If the value is an array representation, convert it\n        const parsedJson = parseValue(fieldValue);\n        // If parsedJson is anything aside from an error, then we want to use the parsed value\n        // This allows us to interpret values like 'null' --> null, 'false' --> false\n        if (!utils.isError(parsedJson) && !utils.isInvalid(parsedJson)) {\n            return parsedJson;\n        }\n        else if (fieldValue === 'undefined') {\n            return undefined;\n        }\n        return fieldValue;\n    }\n    /**\n     * Trims the record value, if specified by the user via the options object\n     */\n    function trimRecordValue(fieldValue) {\n        if (options.trimFieldValues && fieldValue !== null) {\n            return fieldValue.trim();\n        }\n        return fieldValue;\n    }\n    /**\n     * Create a JSON document with the given keys (designated by the CSV header)\n     *   and the values (from the given line)\n     * @returns {Object} created json document\n     */\n    function createDocument(headerFields, line) {\n        // Reduce the keys into a JSON document representing the given line\n        return headerFields.reduce((document, headerField) => {\n            // If there is a value at the key's index in the line, set the value; otherwise null\n            const value = retrieveRecordValueFromLine(headerField, line);\n            try {\n                // Otherwise add the key and value to the document\n                return (0, doc_path_1.setPath)(document, headerField.value, value);\n            }\n            catch (error) {\n                // Catch any errors where key paths are null or '' and continue\n                return document;\n            }\n        }, {});\n    }\n    /**\n     * Removes the outermost wrap delimiters from a value, if they are present\n     * Otherwise, the non-wrapped value is returned as is\n     */\n    function removeWrapDelimitersFromValue(fieldValue) {\n        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n        // If the field starts and ends with a wrap delimiter\n        if (firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap) {\n            // Handle the case where the field is just a pair of wrap delimiters \n            return fieldValue.length <= 2 ? '' : fieldValue.substring(1, lastIndex);\n        }\n        return fieldValue;\n    }\n    /**\n     * Unescapes wrap delimiters by replacing duplicates with a single (eg. \"\" -> \")\n     * This is done in order to parse RFC 4180 compliant CSV back to JSON\n     */\n    function unescapeWrapDelimiterInField(fieldValue) {\n        return fieldValue.replace(escapedWrapDelimiterRegex, options.delimiter.wrap);\n    }\n    /**\n     * Main helper function to convert the CSV to the JSON document array\n     */\n    function transformRecordLines(params) {\n        // For each line, create the document and add it to the array of documents\n        return params.recordLines.reduce((generatedJsonObjects, line) => {\n            line = line.map((fieldValue) => {\n                // Perform the necessary operations on each line\n                fieldValue = removeWrapDelimitersFromValue(fieldValue);\n                fieldValue = unescapeWrapDelimiterInField(fieldValue);\n                fieldValue = trimRecordValue(fieldValue);\n                return fieldValue;\n            });\n            const generatedDocument = createDocument(params.headerFields, line);\n            return generatedJsonObjects.concat(generatedDocument);\n        }, []);\n    }\n    /**\n     * Attempts to parse the provided value. If it is not parsable, then an error is returned\n     */\n    function parseValue(value) {\n        try {\n            if (utils.isStringRepresentation(value, options) && !utils.isDateRepresentation(value)) {\n                return value;\n            }\n            const parsedJson = valueParserFn(value);\n            // If the parsed value is an array, then we also need to trim record values, if specified\n            if (Array.isArray(parsedJson)) {\n                return parsedJson.map(trimRecordValue);\n            }\n            return parsedJson;\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    /**\n     * Internally exported csv2json function\n     */\n    function convert(data) {\n        // Split the CSV into lines using the specified EOL option\n        const stripped = stripExcelBOM(data);\n        const split = splitLines(stripped);\n        const heading = retrieveHeading(split); // Retrieve the headings from the CSV, unless the user specified the keys\n        const lines = retrieveRecordLines(heading); // Retrieve the record lines from the CSV\n        return transformRecordLines(lines); // Retrieve the JSON document array\n    }\n    return {\n        convert,\n    };\n};\nexports.Csv2Json = Csv2Json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvY3N2Mmpzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxvREFBb0Q7QUFDcEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2NzdjJqc29uLmpzP2JjZDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNzdjJKc29uID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgQ3N2Mkpzb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IGVzY2FwZWRXcmFwRGVsaW1pdGVyUmVnZXggPSBuZXcgUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgKyBvcHRpb25zLmRlbGltaXRlci53cmFwLCAnZycpLCBleGNlbEJPTVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBjb25zdGFudHNfMS5leGNlbEJPTSksIHZhbHVlUGFyc2VyRm4gPSBvcHRpb25zLnBhcnNlVmFsdWUgJiYgdHlwZW9mIG9wdGlvbnMucGFyc2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucGFyc2VWYWx1ZSA6IEpTT04ucGFyc2U7XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIGhlYWRlciBrZXksIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyS2V5KGhlYWRlcktleSkge1xuICAgICAgICBoZWFkZXJLZXkgPSByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShoZWFkZXJLZXkpO1xuICAgICAgICBpZiAob3B0aW9ucy50cmltSGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyS2V5LnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAubWFwKChjb21wb25lbnQpID0+IGNvbXBvbmVudC50cmltKCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgSlNPTiBoZWFkaW5nIGZyb20gdGhlIENTVlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlSGVhZGluZyhsaW5lcykge1xuICAgICAgICBsZXQgaGVhZGVyRmllbGRzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlckZpZWxkcykge1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gb3B0aW9ucy5oZWFkZXJGaWVsZHMubWFwKChoZWFkZXJGaWVsZCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2Nlc3NIZWFkZXJLZXkoaGVhZGVyRmllbGQpLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhbmQgcmV0dXJuIHRoZSBoZWFkaW5nIGtleXNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclJvdyA9IGxpbmVzWzBdO1xuICAgICAgICAgICAgaGVhZGVyRmllbGRzID0gaGVhZGVyUm93Lm1hcCgoaGVhZGVyS2V5LCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvY2Vzc0hlYWRlcktleShoZWFkZXJLZXkpLFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBrZXlzLCBmaWx0ZXIgdGhlIGdlbmVyYXRlZCBrZXlzIHRvIGp1c3QgdGhlIHVzZXIgcHJvdmlkZWQga2V5cyBzbyB3ZSBhbHNvIGhhdmUgdGhlIGtleSBpbmRleFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLmtleXM7IC8vIFR5cGVTY3JpcHQgdHlwZSBjaGVja2luZyB3b3JrIGFyb3VuZCB0byBnZXQgaXQgdG8gcmVjb2duaXplIHRoZSBvcHRpb24gaXMgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGhlYWRlckZpZWxkcyA9IGhlYWRlckZpZWxkcy5maWx0ZXIoKGhlYWRlcktleSkgPT4ga2V5cy5pbmNsdWRlcyhoZWFkZXJLZXkudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBoZWFkZXJGaWVsZHMsXG4gICAgICAgICAgICByZWNvcmRMaW5lczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIEV4Y2VsIEJPTSB2YWx1ZSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmlwRXhjZWxCT00oY3N2KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4Y2VsQk9NKSB7XG4gICAgICAgICAgICByZXR1cm4gY3N2LnJlcGxhY2UoZXhjZWxCT01SZWdleCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3Y7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHNwbGl0cyBhIGxpbmUgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHdyYXBwZWQgZmllbGRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXRMaW5lcyhjc3YpIHtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBsaW5lLi4uXG4gICAgICAgIGNvbnN0IGxpbmVzID0gW10sIGxhc3RDaGFyYWN0ZXJJbmRleCA9IGNzdi5sZW5ndGggLSAxLCBlb2xEZWxpbWl0ZXJMZW5ndGggPSBvcHRpb25zLmRlbGltaXRlci5lb2wubGVuZ3RoLCBzdGF0ZVZhcmlhYmxlcyA9IHtcbiAgICAgICAgICAgIGluc2lkZVdyYXBEZWxpbWl0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2luZ1ZhbHVlOiB0cnVlLFxuICAgICAgICAgICAganVzdFBhcnNlZERvdWJsZVF1b3RlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IDBcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNwbGl0TGluZSA9IFtdLCBjaGFyYWN0ZXIsIGNoYXJCZWZvcmUsIGNoYXJBZnRlciwgbmV4dE5DaGFyLCBpbmRleCA9IDA7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgbGluZSB0byBpZGVudGlmeSB3aGVyZSB0byBzcGxpdCB0aGUgdmFsdWVzXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGNzdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBjc3ZbaW5kZXhdO1xuICAgICAgICAgICAgLy8gUHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgICAgICBjaGFyQmVmb3JlID0gaW5kZXggPyBjc3ZbaW5kZXggLSAxXSA6ICcnO1xuICAgICAgICAgICAgLy8gTmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGNoYXJBZnRlciA9IGluZGV4IDwgbGFzdENoYXJhY3RlckluZGV4ID8gY3N2W2luZGV4ICsgMV0gOiAnJztcbiAgICAgICAgICAgIC8vIE5leHQgbiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLCB3aGVyZSBuID0gbGVuZ3RoKEVPTCBkZWxpbWl0ZXIpXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3IgdGhlIGNoZWNraW5nIG9mIGFuIEVPTCBkZWxpbWl0ZXIgd2hlbiBpZiBpdCBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hhcmFjdGVyIChlZy4gJ1xcclxcbicpXG4gICAgICAgICAgICBuZXh0TkNoYXIgPSB1dGlscy5nZXROQ2hhcmFjdGVycyhjc3YsIGluZGV4LCBlb2xEZWxpbWl0ZXJMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKChuZXh0TkNoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCAmJiAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgIGluZGV4ID09PSBsYXN0Q2hhcmFjdGVySW5kZXgpICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhbiBFT0wgZGVsaW1pdGVyIG9yIHRoZSBlbmQgb2YgdGhlIGNzdiBhbmQgdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpcyBhIGZpZWxkIGRlbGltaXRlci4uLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdGFydCBpbmRleCBpcyB0aGUgY3VycmVudCBpbmRleCAoYW5kIHNpbmNlIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBjb21tYSksXG4gICAgICAgICAgICAgICAgLy8gICB0aGVuIHRoZSB2YWx1ZSBiZWluZyBwYXJzZWQgaXMgYW4gZW1wdHkgdmFsdWUgYWNjb3JkaW5nbHksIGFkZCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5DaGFyID09PSBvcHRpb25zLmRlbGltaXRlci5lb2wgJiYgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgQ1NWLCB0aGVyZSdzIG5vIG5ldyBsaW5lLCBhbmQgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY29tbWFcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBhZGQgYW4gZW1wdHkgc3RyaW5nIGZvciB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZXJlJ3MgYSB2YWxpZCB2YWx1ZSwgYW5kIHRoZSBzdGFydCBpbmRleCBpc24ndCB0aGUgY3VycmVudCBpbmRleCwgZ3JhYiB0aGUgd2hvbGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBhIGNvbW1hLCB0aGVyZSdzIHN0aWxsIGFuIGFkZGl0aW9uYWwgaW1wbGllZCBmaWVsZCB2YWx1ZSB0cmFpbGluZyB0aGUgY29tbWEuXG4gICAgICAgICAgICAgICAgLy8gICBTaW5jZSB0aGlzIHZhbHVlIGlzIGVtcHR5LCB3ZSBwdXNoIGFuIGV4dHJhIGVtcHR5IHZhbHVlXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHB1c2ggdGhlIHNwbGl0IGxpbmUgdmFsdWVzIGludG8gdGhlIGxpbmVzIGFycmF5IGFuZCBjbGVhciB0aGUgc3BsaXQgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goc3BsaXRMaW5lKTtcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyBlb2xEZWxpbWl0ZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IGxhc3RDaGFyYWN0ZXJJbmRleCAmJiBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgQ1NWIGFuZCB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgcHJldmlvdXNseSBzZWVuIHZhbHVlIGFuZCBhZGQgaXQgdG8gdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCBhbiBlbXB0eSBzdHJpbmcgdG8gdGhlIGxpbmUgc2luY2UgdGhlIGxhc3QgY2hhcmFjdGVyIGJlaW5nIGEgZmllbGQgZGVsaW1pdGVyIGluZGljYXRlcyBhbiBlbXB0eSBmaWVsZFxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHNwbGl0TGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gbGFzdENoYXJhY3RlckluZGV4IHx8IG5leHROQ2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlbid0IGluc2lkZSB3cmFwIGRlbGltaXRlcnMgb3IgaWYgd2UgYXJlIGJ1dCB0aGUgY2hhcmFjdGVyIGJlZm9yZSB3YXMgYSB3cmFwIGRlbGltaXRlciBhbmQgd2UgZGlkbid0IGp1c3Qgc2VlIHR3b1xuICAgICAgICAgICAgICAgICghc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyICYmIGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsaW5lIG9yIGNzdiAoYW5kIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhIGZpZWxkIGRlbGltaXRlcilcbiAgICAgICAgICAgICAgICBjb25zdCB0b0luZGV4ID0gaW5kZXggIT09IGxhc3RDaGFyYWN0ZXJJbmRleCB8fCBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwID8gaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlbWFpbmluZyB2YWx1ZSBhbmQgYWRkIGl0IHRvIHRoZSBzcGxpdCBsaW5lIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCB0b0luZGV4KSk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcHVzaCB0aGUgc3BsaXQgbGluZSB2YWx1ZXMgaW50byB0aGUgbGluZXMgYXJyYXkgYW5kIGNsZWFyIHRoZSBzcGxpdCBsaW5lXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzcGxpdExpbmUpO1xuICAgICAgICAgICAgICAgIHNwbGl0TGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIGVvbERlbGltaXRlckxlbmd0aDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiZcbiAgICAgICAgICAgICAgICAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiAhc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHdyYXAgZGVsaW1pdGVyIGFmdGVyIGEgY29tbWEgYW5kIHdlIGFyZW4ndCBpbnNpZGUgYSB3cmFwIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGNoYXJhY3RlcihzKSBhcmUgYW4gRU9MIGRlbGltaXRlciwgdGhlbiBza2lwIHRoZW0gc28gd2UgZG9uJ3QgcGFyc2Ugd2hhdCB3ZSd2ZSBzZWVuIGFzIGFub3RoZXIgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCArIDEsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBvcHRpb25zLmRlbGltaXRlci5lb2wubGVuZ3RoICsgMTsgLy8gU2tpcCBwYXN0IEVPTFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJCZWZvcmUgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZCBuZXcgZmllbGQgdGhhdCBiZWdpbnMgd2l0aCBhbiBFT0wgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHJlbWFpbmluZyB2YWx1ZSBhbmQgYWRkIGl0IHRvIHRoZSBzcGxpdCBsaW5lIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoY2hhckJlZm9yZSAhPT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCB8fCBzdGF0ZVZhcmlhYmxlcy5qdXN0UGFyc2VkRG91YmxlUXVvdGUgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkgJiZcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCArIDEsIGVvbERlbGltaXRlckxlbmd0aCkgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmVvbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGEgd3JhcCB3aGljaCBpcyBub3QgcHJlY2VkZWQgYnkgYSB3cmFwIGRlbGltIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW4gRU9MIGRlbGltIChpZS4gKlwiXFxuKVxuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGl0ZXJhdGlvbiB3aWxsIHN1YnN0cmluZywgYWRkIHRoZSB2YWx1ZSB0byB0aGUgbGluZSwgYW5kIHB1c2ggdGhlIGxpbmUgb250byB0aGUgYXJyYXkgb2YgbGluZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiAoaW5kZXggPT09IDAgfHwgdXRpbHMuZ2V0TkNoYXJhY3RlcnMoY3N2LCBpbmRleCAtIGVvbERlbGltaXRlckxlbmd0aCwgZW9sRGVsaW1pdGVyTGVuZ3RoKSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZW9sICYmICFzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgd3JhcCBkZWxpbWl0ZXIgKGllLiBcIiopXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckFmdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSB3cmFwIGRlbGltaXRlciB3aXRoIGEgZmllbGQgZGVsaW1pdGVyIGFmdGVyIGl0IChpZS4gKlwiLClcbiAgICAgICAgICAgICAgICBzcGxpdExpbmUucHVzaChjc3Yuc3Vic3RyaW5nKHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgsIGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleCArIDI7IC8vIG5leHQgdmFsdWUgc3RhcnRzIGFmdGVyIHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMucGFyc2luZ1ZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgY2hhckJlZm9yZSA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQgJiZcbiAgICAgICAgICAgICAgICAhc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciAmJiBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgd3JhcCBkZWxpbWl0ZXIgd2l0aCBhIGZpZWxkIGRlbGltaXRlciBhZnRlciBpdCAoaWUuICxcIiopXG4gICAgICAgICAgICAgICAgc3BsaXRMaW5lLnB1c2goY3N2LnN1YnN0cmluZyhzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4LCBpbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5pbnNpZGVXcmFwRGVsaW1pdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBjaGFyQWZ0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgaW5kZXggIT09IHN0YXRlVmFyaWFibGVzLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBydW4gaW50byBhbiBlc2NhcGVkIHF1b3RlIChpZS4gXCJcIikgc2tpcCBwYXN0IHRoZSBzZWNvbmQgcXVvdGVcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLmp1c3RQYXJzZWREb3VibGVRdW90ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLmZpZWxkICYmIGNoYXJCZWZvcmUgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiZcbiAgICAgICAgICAgICAgICBjaGFyQWZ0ZXIgIT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgIXN0YXRlVmFyaWFibGVzLmluc2lkZVdyYXBEZWxpbWl0ZXIgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgZmllbGQgZGVsaW1pdGVyIGFuZCBhcmUgbm90IGluc2lkZSB0aGUgd3JhcCBkZWxpbWl0ZXJzIChpZS4gKiwqKVxuICAgICAgICAgICAgICAgIHNwbGl0TGluZS5wdXNoKGNzdi5zdWJzdHJpbmcoc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVZhcmlhYmxlcy5zdGFydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID09PSBvcHRpb25zLmRlbGltaXRlci5maWVsZCAmJiBjaGFyQmVmb3JlID09PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmXG4gICAgICAgICAgICAgICAgY2hhckFmdGVyICE9PSBvcHRpb25zLmRlbGltaXRlci53cmFwICYmICFzdGF0ZVZhcmlhYmxlcy5wYXJzaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgZmllbGQgZGVsaW1pdGVyLCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyBhIHdyYXAgZGVsaW1pdGVyLCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBuZXh0IGNoYXJhY3RlciBpcyBub3QgYSB3cmFwIGRlbGltaXRlciAoaWUuIFwiLCopXG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuaW5zaWRlV3JhcERlbGltaXRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXRlVmFyaWFibGVzLnBhcnNpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuc3RhcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgdG8gdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGRvdWJsZSBxdW90ZSBzdGF0ZSB2YXJpYWJsZVxuICAgICAgICAgICAgc3RhdGVWYXJpYWJsZXMuanVzdFBhcnNlZERvdWJsZVF1b3RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlY29yZCBsaW5lcyBmcm9tIHRoZSBzcGxpdCBDU1YgbGluZXMgYW5kIHNldHMgaXQgb24gdGhlIHBhcmFtcyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZExpbmVzKHBhcmFtcykge1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJGaWVsZHMpIHsgLy8gVGhpcyBvcHRpb24gaXMgcGFzc2VkIGZvciBpbnN0YW5jZXMgd2hlcmUgdGhlIENTViBoYXMgbm8gaGVhZGVyIGxpbmVcbiAgICAgICAgICAgIHBhcmFtcy5yZWNvcmRMaW5lcyA9IHBhcmFtcy5saW5lcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWxsIGxpbmVzIGV4Y2VwdCBmb3IgdGhlIGhlYWRlciBsaW5lXG4gICAgICAgICAgICBwYXJhbXMucmVjb3JkTGluZXMgPSBwYXJhbXMubGluZXMuc3BsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgZm9yIHRoZSByZWNvcmQgZnJvbSB0aGUgbGluZSBhdCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjb3JkVmFsdWVGcm9tTGluZShoZWFkZXJGaWVsZCwgbGluZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHZhbHVlIGF0IHRoZSBrZXkncyBpbmRleCwgdXNlIGl0OyBvdGhlcndpc2UsIG51bGxcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaW5lW2hlYWRlckZpZWxkLmluZGV4XTtcbiAgICAgICAgLy8gUGVyZm9ybSBhbnkgbmVjZXNzYXJ5IHZhbHVlIGNvbnZlcnNpb25zIG9uIHRoZSByZWNvcmQgdmFsdWVcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZWNvcmRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgcmVjb3JkJ3MgdmFsdWUgYnkgcGFyc2luZyB0aGUgZGF0YSB0byBlbnN1cmUgdGhlIENTViBpc1xuICAgICAqIGNvbnZlcnRlZCB0byB0aGUgSlNPTiB0aGF0IGNyZWF0ZWQgaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uLCBjb252ZXJ0IGl0XG4gICAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSBwYXJzZVZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAvLyBJZiBwYXJzZWRKc29uIGlzIGFueXRoaW5nIGFzaWRlIGZyb20gYW4gZXJyb3IsIHRoZW4gd2Ugd2FudCB0byB1c2UgdGhlIHBhcnNlZCB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBpbnRlcnByZXQgdmFsdWVzIGxpa2UgJ251bGwnIC0tPiBudWxsLCAnZmFsc2UnIC0tPiBmYWxzZVxuICAgICAgICBpZiAoIXV0aWxzLmlzRXJyb3IocGFyc2VkSnNvbikgJiYgIXV0aWxzLmlzSW52YWxpZChwYXJzZWRKc29uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSByZWNvcmQgdmFsdWUsIGlmIHNwZWNpZmllZCBieSB0aGUgdXNlciB2aWEgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUZpZWxkVmFsdWVzICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgSlNPTiBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBrZXlzIChkZXNpZ25hdGVkIGJ5IHRoZSBDU1YgaGVhZGVyKVxuICAgICAqICAgYW5kIHRoZSB2YWx1ZXMgKGZyb20gdGhlIGdpdmVuIGxpbmUpXG4gICAgICogQHJldHVybnMge09iamVjdH0gY3JlYXRlZCBqc29uIGRvY3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoaGVhZGVyRmllbGRzLCBsaW5lKSB7XG4gICAgICAgIC8vIFJlZHVjZSB0aGUga2V5cyBpbnRvIGEgSlNPTiBkb2N1bWVudCByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxpbmVcbiAgICAgICAgcmV0dXJuIGhlYWRlckZpZWxkcy5yZWR1Y2UoKGRvY3VtZW50LCBoZWFkZXJGaWVsZCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB2YWx1ZSBhdCB0aGUga2V5J3MgaW5kZXggaW4gdGhlIGxpbmUsIHNldCB0aGUgdmFsdWU7IG90aGVyd2lzZSBudWxsXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJldHJpZXZlUmVjb3JkVmFsdWVGcm9tTGluZShoZWFkZXJGaWVsZCwgbGluZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgdGhlIGtleSBhbmQgdmFsdWUgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBkb2NfcGF0aF8xLnNldFBhdGgpKGRvY3VtZW50LCBoZWFkZXJGaWVsZC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB3aGVyZSBrZXkgcGF0aHMgYXJlIG51bGwgb3IgJycgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG91dGVybW9zdCB3cmFwIGRlbGltaXRlcnMgZnJvbSBhIHZhbHVlLCBpZiB0aGV5IGFyZSBwcmVzZW50XG4gICAgICogT3RoZXJ3aXNlLCB0aGUgbm9uLXdyYXBwZWQgdmFsdWUgaXMgcmV0dXJuZWQgYXMgaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpZWxkVmFsdWVbMF0sIGxhc3RJbmRleCA9IGZpZWxkVmFsdWUubGVuZ3RoIC0gMSwgbGFzdENoYXIgPSBmaWVsZFZhbHVlW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgICAgIGlmIChmaXJzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXAgJiYgbGFzdENoYXIgPT09IG9wdGlvbnMuZGVsaW1pdGVyLndyYXApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgZmllbGQgaXMganVzdCBhIHBhaXIgb2Ygd3JhcCBkZWxpbWl0ZXJzIFxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubGVuZ3RoIDw9IDIgPyAnJyA6IGZpZWxkVmFsdWUuc3Vic3RyaW5nKDEsIGxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuZXNjYXBlcyB3cmFwIGRlbGltaXRlcnMgYnkgcmVwbGFjaW5nIGR1cGxpY2F0ZXMgd2l0aCBhIHNpbmdsZSAoZWcuIFwiXCIgLT4gXCIpXG4gICAgICogVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHBhcnNlIFJGQyA0MTgwIGNvbXBsaWFudCBDU1YgYmFjayB0byBKU09OXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZChmaWVsZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnJlcGxhY2UoZXNjYXBlZFdyYXBEZWxpbWl0ZXJSZWdleCwgb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1haW4gaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdGhlIENTViB0byB0aGUgSlNPTiBkb2N1bWVudCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlY29yZExpbmVzKHBhcmFtcykge1xuICAgICAgICAvLyBGb3IgZWFjaCBsaW5lLCBjcmVhdGUgdGhlIGRvY3VtZW50IGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIGRvY3VtZW50c1xuICAgICAgICByZXR1cm4gcGFyYW1zLnJlY29yZExpbmVzLnJlZHVjZSgoZ2VuZXJhdGVkSnNvbk9iamVjdHMsIGxpbmUpID0+IHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLm1hcCgoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG5lY2Vzc2FyeSBvcGVyYXRpb25zIG9uIGVhY2ggbGluZVxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSByZW1vdmVXcmFwRGVsaW1pdGVyc0Zyb21WYWx1ZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdW5lc2NhcGVXcmFwRGVsaW1pdGVySW5GaWVsZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gdHJpbVJlY29yZFZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWREb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KHBhcmFtcy5oZWFkZXJGaWVsZHMsIGxpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEpzb25PYmplY3RzLmNvbmNhdChnZW5lcmF0ZWREb2N1bWVudCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgdGhlIHByb3ZpZGVkIHZhbHVlLiBJZiBpdCBpcyBub3QgcGFyc2FibGUsIHRoZW4gYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbih2YWx1ZSwgb3B0aW9ucykgJiYgIXV0aWxzLmlzRGF0ZVJlcHJlc2VudGF0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSB2YWx1ZVBhcnNlckZuKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJzZWQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gd2UgYWxzbyBuZWVkIHRvIHRyaW0gcmVjb3JkIHZhbHVlcywgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRKc29uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRKc29uLm1hcCh0cmltUmVjb3JkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEpzb247XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IGV4cG9ydGVkIGNzdjJqc29uIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydChkYXRhKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBDU1YgaW50byBsaW5lcyB1c2luZyB0aGUgc3BlY2lmaWVkIEVPTCBvcHRpb25cbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEV4Y2VsQk9NKGRhdGEpO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHNwbGl0TGluZXMoc3RyaXBwZWQpO1xuICAgICAgICBjb25zdCBoZWFkaW5nID0gcmV0cmlldmVIZWFkaW5nKHNwbGl0KTsgLy8gUmV0cmlldmUgdGhlIGhlYWRpbmdzIGZyb20gdGhlIENTViwgdW5sZXNzIHRoZSB1c2VyIHNwZWNpZmllZCB0aGUga2V5c1xuICAgICAgICBjb25zdCBsaW5lcyA9IHJldHJpZXZlUmVjb3JkTGluZXMoaGVhZGluZyk7IC8vIFJldHJpZXZlIHRoZSByZWNvcmQgbGluZXMgZnJvbSB0aGUgQ1NWXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1SZWNvcmRMaW5lcyhsaW5lcyk7IC8vIFJldHJpZXZlIHRoZSBKU09OIGRvY3VtZW50IGFycmF5XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnZlcnQsXG4gICAgfTtcbn07XG5leHBvcnRzLkNzdjJKc29uID0gQ3N2Mkpzb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/csv2json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/json2csv.js":
/*!*************************************************!*\
  !*** ./node_modules/json-2-csv/lib/json2csv.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Json2Csv = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst deeks_1 = __webpack_require__(/*! deeks */ \"(ssr)/./node_modules/deeks/lib/deeks.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/json-2-csv/lib/utils.js\"));\nconst Json2Csv = function (options) {\n    const wrapDelimiterCheckRegex = new RegExp(options.delimiter.wrap, 'g'), crlfSearchRegex = /\\r?\\n|\\r/, customValueParser = options.parseValue && typeof options.parseValue === 'function' ? options.parseValue : null, expandingWithoutUnwinding = options.expandArrayObjects && !options.unwindArrays, deeksOptions = {\n        arrayIndexesAsKeys: options.arrayIndexesAsKeys,\n        expandNestedObjects: options.expandNestedObjects,\n        expandArrayObjects: expandingWithoutUnwinding,\n        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,\n        escapeNestedDots: true,\n    };\n    /** HEADER FIELD FUNCTIONS **/\n    /**\n     * Returns the list of data field names of all documents in the provided list\n     */\n    function getFieldNameList(data) {\n        // If keys weren't specified, then we'll use the list of keys generated by the deeks module\n        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);\n    }\n    /**\n     * Processes the schemas by checking for schema differences, if so desired.\n     * If schema differences are not to be checked, then it resolves the unique\n     * list of field names.\n     */\n    function processSchemas(documentSchemas) {\n        // If there are no document schemas then there is nothing to diff and no unique fields to get\n        if (documentSchemas.length === 0) {\n            return [];\n        }\n        // If the user wants to check for the same schema (regardless of schema ordering)\n        if (options.checkSchemaDifferences) {\n            return checkSchemaDifferences(documentSchemas);\n        }\n        else {\n            // Otherwise, we do not care if the schemas are different, so we should get the unique list of keys\n            const uniqueFieldNames = utils.unique(utils.flatten(documentSchemas));\n            return uniqueFieldNames;\n        }\n    }\n    /**\n     * This function performs the schema difference check, if the user specifies that it should be checked.\n     * If there are no field names, then there are no differences.\n     * Otherwise, we get the first schema and the remaining list of schemas\n     */\n    function checkSchemaDifferences(documentSchemas) {\n        // have multiple documents - ensure only one schema (regardless of field ordering)\n        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            throw new Error(constants_1.errors.json2csv.notSameSchema);\n        }\n        return firstDocSchema;\n    }\n    /**\n     * Computes the number of schema differences\n     */\n    function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {\n        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            const numberOfDifferences = utils.computeSchemaDifferences(firstDocSchema, documentSchema).length;\n            return numberOfDifferences > 0\n                ? schemaDifferences + 1\n                : schemaDifferences;\n        }, 0);\n    }\n    /**\n     * If so specified, this filters the detected key paths to exclude any keys that have been specified\n     */\n    function filterExcludedKeys(keyPaths) {\n        if (options.excludeKeys) {\n            return keyPaths.filter((keyPath) => {\n                for (const excludedKey of options.excludeKeys) {\n                    // Only match if the excludedKey appears at the beginning of the string so we don't accidentally match a key farther down in a key path\n                    const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);\n                    if (excludedKey === keyPath || keyPath.match(regex)) {\n                        return false; // Exclude the key\n                    }\n                }\n                return true; // Otherwise, include the key\n            });\n        }\n        return keyPaths;\n    }\n    /**\n     * If so specified, this sorts the header field names alphabetically\n     */\n    function sortHeaderFields(fieldNames) {\n        if (options.sortHeader && typeof options.sortHeader === 'function') {\n            return fieldNames.sort(options.sortHeader);\n        }\n        else if (options.sortHeader) {\n            return fieldNames.sort();\n        }\n        return fieldNames;\n    }\n    /**\n     * Trims the header fields, if the user desires them to be trimmed.\n     */\n    function trimHeaderFields(params) {\n        if (options.trimHeaderFields) {\n            params.headerFields = params.headerFields.map((field) => field.split('.')\n                .map((component) => component.trim())\n                .join('.'));\n        }\n        return params;\n    }\n    /**\n     * Wrap the headings, if desired by the user.\n     */\n    function wrapHeaderFields(params) {\n        // only perform this if we are actually prepending the header\n        if (options.prependHeader) {\n            params.headerFields = params.headerFields.map(function (headingKey) {\n                return wrapFieldValueIfNecessary(headingKey);\n            });\n        }\n        return params;\n    }\n    /**\n     * Generates the CSV header string by joining the headerFields by the field delimiter\n     */\n    function generateCsvHeader(params) {\n        // #185 - generate a keys list to avoid finding native Map() methods\n        const fieldTitleMapKeys = Object.keys(options.fieldTitleMap);\n        params.header = params.headerFields\n            .map(function (field) {\n            let headerKey = field;\n            // If a custom field title was provided for this field, use that\n            if (fieldTitleMapKeys.includes(field)) {\n                headerKey = options.fieldTitleMap[field];\n            }\n            else if (!options.escapeHeaderNestedDots) {\n                // Otherwise, if the user doesn't want nested dots in keys to be escaped, then unescape them\n                headerKey = headerKey.replace(/\\\\\\./g, '.');\n            }\n            return headerKey;\n        })\n            .join(options.delimiter.field);\n        return params;\n    }\n    function convertKeysToHeaderFields() {\n        if (!options.keys)\n            return [];\n        return options.keys.map((key) => {\n            if (typeof key === 'object' && 'field' in key) {\n                options.fieldTitleMap[key.field] = key.title ?? key.field;\n                return key.field;\n            }\n            return key;\n        });\n    }\n    function extractWildcardMatchKeys() {\n        if (!options.keys)\n            return [];\n        return options.keys.flatMap(item => {\n            if (typeof item === 'string') {\n                // Exclude plain strings that were passed in options.keys\n                return [];\n            }\n            else if (item?.wildcardMatch) {\n                // Return \"field\" value for objects with wildcardMatch: true\n                return item.field;\n            }\n            // Exclude other objects\n            return [];\n        });\n    }\n    /**\n     * Retrieve the headings for all documents and return it.\n     * This checks that all documents have the same schema.\n     */\n    function retrieveHeaderFields(data) {\n        const wildcardMatchKeys = extractWildcardMatchKeys();\n        const keyStrings = convertKeysToHeaderFields();\n        const fieldNames = getFieldNameList(data);\n        const processed = processSchemas(fieldNames);\n        if (options.keys) {\n            options.keys = keyStrings;\n            const matchedKeys = keyStrings.flatMap((userProvidedKey) => {\n                // If this is not a wildcard matched key, then just return and include it in the resulting key list\n                if (!wildcardMatchKeys.includes(userProvidedKey)) {\n                    return userProvidedKey;\n                }\n                // Otherwise, identify all detected keys that match with the provided wildcard key:\n                const matches = [];\n                const regex = new RegExp(`^${userProvidedKey}`);\n                for (const detectedKey of processed) {\n                    if (userProvidedKey === detectedKey || detectedKey.match(regex)) {\n                        matches.push(detectedKey);\n                    }\n                }\n                return matches;\n            });\n            if (!options.unwindArrays) {\n                const filtered = filterExcludedKeys(matchedKeys);\n                return sortHeaderFields(filtered);\n            }\n        }\n        const filtered = filterExcludedKeys(processed);\n        return sortHeaderFields(filtered);\n    }\n    /** RECORD FIELD FUNCTIONS **/\n    /**\n     * Unwinds objects in arrays within record objects if the user specifies the\n     * expandArrayObjects option. If not specified, this passes the params\n     * argument through to the next function in the promise chain.\n     *\n     * The `finalPass` parameter is used to trigger one last pass to ensure no more\n     * arrays need to be expanded\n     */\n    function unwindRecordsIfNecessary(params, finalPass = false) {\n        if (options.unwindArrays) {\n            const originalRecordsLength = params.records.length;\n            // Unwind each of the documents at the given headerField\n            params.headerFields.forEach((headerField) => {\n                params.records = utils.unwind(params.records, headerField);\n            });\n            const headerFields = retrieveHeaderFields(params.records);\n            params.headerFields = headerFields;\n            // If we were able to unwind more arrays, then try unwinding again...\n            if (originalRecordsLength !== params.records.length) {\n                return unwindRecordsIfNecessary(params);\n            }\n            // Otherwise, we didn't unwind any additional arrays, so continue...\n            // Run a final time in case the earlier unwinding exposed additional\n            // arrays to unwind...\n            if (!finalPass) {\n                return unwindRecordsIfNecessary(params, true);\n            }\n            // If keys were provided, set the headerFields back to the provided keys after unwinding:\n            if (options.keys) {\n                const userSelectedFields = convertKeysToHeaderFields();\n                params.headerFields = filterExcludedKeys(userSelectedFields);\n            }\n            return params;\n        }\n        return params;\n    }\n    /**\n     * Main function which handles the processing of a record, or document to be converted to CSV format\n     * This function specifies and performs the necessary operations in the necessary order\n     * in order to obtain the data and convert it to CSV form while maintaining RFC 4180 compliance.\n     * * Order of operations:\n     * - Get fields from provided key list (as array of actual values)\n     * - Convert the values to csv/string representation [possible option here for custom converters?]\n     * - Trim fields\n     * - Determine if they need to be wrapped (& wrap if necessary)\n     * - Combine values for each line (by joining by field delimiter)\n     */\n    function processRecords(params) {\n        params.recordString = params.records.map((record) => {\n            // Retrieve data for each of the headerFields from this record\n            const recordFieldData = retrieveRecordFieldData(record, params.headerFields), \n            // Process the data in this record and return the\n            processedRecordData = recordFieldData.map((fieldValue) => {\n                fieldValue = trimRecordFieldValue(fieldValue);\n                fieldValue = preventCsvInjection(fieldValue);\n                let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);\n                stringified = wrapFieldValueIfNecessary(stringified);\n                return stringified;\n            });\n            // Join the record data by the field delimiter\n            return generateCsvRowFromRecord(processedRecordData);\n        }).join(options.delimiter.eol);\n        return params;\n    }\n    /**\n     * Helper function intended to process *just* array values when the expandArrayObjects setting is set to true\n     */\n    function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {\n        const filteredRecordFieldValue = utils.removeEmptyFields(recordFieldValue);\n        // If we have an array and it's either empty of full of empty values, then use an empty value representation\n        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {\n            return options.emptyFieldValue || '';\n        }\n        else if (filteredRecordFieldValue.length === 1) {\n            // Otherwise, we have an array of actual values...\n            // Since we are expanding array objects, we will want to key in on values of objects.\n            return filteredRecordFieldValue[0]; // Extract the single value in the array\n        }\n        return recordFieldValue;\n    }\n    /**\n     * Gets all field values from a particular record for the given list of fields\n     */\n    function retrieveRecordFieldData(record, fields) {\n        const recordValues = [];\n        fields.forEach((field) => {\n            let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);\n            if (!utils.isUndefined(options.emptyFieldValue) && utils.isEmptyField(recordFieldValue)) {\n                recordFieldValue = options.emptyFieldValue;\n            }\n            else if (options.expandArrayObjects && Array.isArray(recordFieldValue)) {\n                recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);\n            }\n            recordValues.push(recordFieldValue);\n        });\n        return recordValues;\n    }\n    /**\n     * Converts a record field value to its string representation\n     */\n    function recordFieldValueToString(fieldValue) {\n        const isDate = fieldValue instanceof Date; // store to avoid checking twice\n        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === 'object' && !isDate) {\n            return JSON.stringify(fieldValue);\n        }\n        else if (typeof fieldValue === 'undefined') {\n            return 'undefined';\n        }\n        else if (isDate && options.useDateIso8601Format) {\n            return fieldValue.toISOString();\n        }\n        else {\n            return !options.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();\n        }\n    }\n    /**\n     * Trims the record field value, if specified by the user's provided options\n     */\n    function trimRecordFieldValue(fieldValue) {\n        if (options.trimFieldValues) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(trimRecordFieldValue);\n            }\n            else if (typeof fieldValue === 'string') {\n                return fieldValue.trim();\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Prevent CSV injection on strings if specified by the user's provided options.\n     * Mitigation will be done by ensuring that the first character doesn't being with:\n     * Equals (=), Plus (+), Minus (-), At (@), Tab (0x09), Carriage return (0x0D).\n     * More info: https://owasp.org/www-community/attacks/CSV_Injection\n     */\n    function preventCsvInjection(fieldValue) {\n        if (options.preventCsvInjection) {\n            if (Array.isArray(fieldValue)) {\n                return fieldValue.map(preventCsvInjection);\n            }\n            else if (typeof fieldValue === 'string' && !utils.isNumber(fieldValue)) {\n                return fieldValue.replace(/^[=+\\-@\\t\\r]+/g, '');\n            }\n            return fieldValue;\n        }\n        return fieldValue;\n    }\n    /**\n     * Escapes quotation marks in the field value, if necessary, and appropriately\n     * wraps the record field value if it contains a comma (field delimiter),\n     * quotation mark (wrap delimiter), or a line break (CRLF)\n     */\n    function wrapFieldValueIfNecessary(fieldValue) {\n        const wrapDelimiter = options.delimiter.wrap;\n        // eg. includes quotation marks (default delimiter)\n        if (fieldValue.includes(options.delimiter.wrap)) {\n            // add an additional quotation mark before each quotation mark appearing in the field value\n            fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);\n        }\n        // if the field contains a comma (field delimiter), quotation mark (wrap delimiter), line break, or CRLF\n        //   then enclose it in quotation marks (wrap delimiter)\n        if (fieldValue.includes(options.delimiter.field) ||\n            fieldValue.includes(options.delimiter.wrap) ||\n            fieldValue.match(crlfSearchRegex) ||\n            options.wrapBooleans && (fieldValue === 'true' || fieldValue === 'false')) {\n            // wrap the field's value in a wrap delimiter (quotation marks by default)\n            fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;\n        }\n        return fieldValue;\n    }\n    /**\n     * Generates the CSV record string by joining the field values together by the field delimiter\n     */\n    function generateCsvRowFromRecord(recordFieldValues) {\n        return recordFieldValues.join(options.delimiter.field);\n    }\n    /** CSV COMPONENT COMBINER/FINAL PROCESSOR **/\n    /**\n     * Performs the final CSV construction by combining the fields in the appropriate\n     * order depending on the provided options values and sends the generated CSV\n     * back to the user\n     */\n    function generateCsvFromComponents(params) {\n        const header = params.header, records = params.recordString, \n        // If we are prepending the header, then add an EOL, otherwise just return the records\n        csv = (options.excelBOM ? constants_1.excelBOM : '') +\n            (options.prependHeader ? header + options.delimiter.eol : '') +\n            records;\n        return csv;\n    }\n    /** MAIN CONVERTER FUNCTION **/\n    /**\n     * Internally exported json2csv function\n     */\n    function convert(data) {\n        // Single document, not an array\n        if (!Array.isArray(data)) {\n            data = [data]; // Convert to an array of the given document\n        }\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        const headerFields = {\n            headerFields: retrieveHeaderFields(data),\n            records: data,\n            header: '',\n            recordString: '',\n        };\n        const unwinded = unwindRecordsIfNecessary(headerFields);\n        const processed = processRecords(unwinded);\n        const wrapped = wrapHeaderFields(processed);\n        const trimmed = trimHeaderFields(wrapped);\n        const generated = generateCsvHeader(trimmed);\n        return generateCsvFromComponents(generated);\n    }\n    return {\n        convert,\n    };\n};\nexports.Json2Csv = Json2Csv;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvanNvbjJjc3YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixtQkFBbUIsbUJBQU8sQ0FBQywyREFBVTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBTztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw2REFBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFlBQVk7QUFDM0c7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaXRlLy4vbm9kZV9tb2R1bGVzL2pzb24tMi1jc3YvbGliL2pzb24yY3N2LmpzP2M5YmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb24yQ3N2ID0gdm9pZCAwO1xuY29uc3QgZG9jX3BhdGhfMSA9IHJlcXVpcmUoXCJkb2MtcGF0aFwiKTtcbmNvbnN0IGRlZWtzXzEgPSByZXF1aXJlKFwiZGVla3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IEpzb24yQ3N2ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3cmFwRGVsaW1pdGVyQ2hlY2tSZWdleCA9IG5ldyBSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCwgJ2cnKSwgY3JsZlNlYXJjaFJlZ2V4ID0gL1xccj9cXG58XFxyLywgY3VzdG9tVmFsdWVQYXJzZXIgPSBvcHRpb25zLnBhcnNlVmFsdWUgJiYgdHlwZW9mIG9wdGlvbnMucGFyc2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMucGFyc2VWYWx1ZSA6IG51bGwsIGV4cGFuZGluZ1dpdGhvdXRVbndpbmRpbmcgPSBvcHRpb25zLmV4cGFuZEFycmF5T2JqZWN0cyAmJiAhb3B0aW9ucy51bndpbmRBcnJheXMsIGRlZWtzT3B0aW9ucyA9IHtcbiAgICAgICAgYXJyYXlJbmRleGVzQXNLZXlzOiBvcHRpb25zLmFycmF5SW5kZXhlc0FzS2V5cyxcbiAgICAgICAgZXhwYW5kTmVzdGVkT2JqZWN0czogb3B0aW9ucy5leHBhbmROZXN0ZWRPYmplY3RzLFxuICAgICAgICBleHBhbmRBcnJheU9iamVjdHM6IGV4cGFuZGluZ1dpdGhvdXRVbndpbmRpbmcsXG4gICAgICAgIGlnbm9yZUVtcHR5QXJyYXlzV2hlbkV4cGFuZGluZzogZXhwYW5kaW5nV2l0aG91dFVud2luZGluZyxcbiAgICAgICAgZXNjYXBlTmVzdGVkRG90czogdHJ1ZSxcbiAgICB9O1xuICAgIC8qKiBIRUFERVIgRklFTEQgRlVOQ1RJT05TICoqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZGF0YSBmaWVsZCBuYW1lcyBvZiBhbGwgZG9jdW1lbnRzIGluIHRoZSBwcm92aWRlZCBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RmllbGROYW1lTGlzdChkYXRhKSB7XG4gICAgICAgIC8vIElmIGtleXMgd2VyZW4ndCBzcGVjaWZpZWQsIHRoZW4gd2UnbGwgdXNlIHRoZSBsaXN0IG9mIGtleXMgZ2VuZXJhdGVkIGJ5IHRoZSBkZWVrcyBtb2R1bGVcbiAgICAgICAgcmV0dXJuICgwLCBkZWVrc18xLmRlZXBLZXlzRnJvbUxpc3QpKGRhdGEsIGRlZWtzT3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgc2NoZW1hcyBieSBjaGVja2luZyBmb3Igc2NoZW1hIGRpZmZlcmVuY2VzLCBpZiBzbyBkZXNpcmVkLlxuICAgICAqIElmIHNjaGVtYSBkaWZmZXJlbmNlcyBhcmUgbm90IHRvIGJlIGNoZWNrZWQsIHRoZW4gaXQgcmVzb2x2ZXMgdGhlIHVuaXF1ZVxuICAgICAqIGxpc3Qgb2YgZmllbGQgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NjaGVtYXMoZG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkb2N1bWVudCBzY2hlbWFzIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkaWZmIGFuZCBubyB1bmlxdWUgZmllbGRzIHRvIGdldFxuICAgICAgICBpZiAoZG9jdW1lbnRTY2hlbWFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIGNoZWNrIGZvciB0aGUgc2FtZSBzY2hlbWEgKHJlZ2FyZGxlc3Mgb2Ygc2NoZW1hIG9yZGVyaW5nKVxuICAgICAgICBpZiAob3B0aW9ucy5jaGVja1NjaGVtYURpZmZlcmVuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tTY2hlbWFEaWZmZXJlbmNlcyhkb2N1bWVudFNjaGVtYXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgY2FyZSBpZiB0aGUgc2NoZW1hcyBhcmUgZGlmZmVyZW50LCBzbyB3ZSBzaG91bGQgZ2V0IHRoZSB1bmlxdWUgbGlzdCBvZiBrZXlzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVGaWVsZE5hbWVzID0gdXRpbHMudW5pcXVlKHV0aWxzLmZsYXR0ZW4oZG9jdW1lbnRTY2hlbWFzKSk7XG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlRmllbGROYW1lcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIHRoZSBzY2hlbWEgZGlmZmVyZW5jZSBjaGVjaywgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIHRoYXQgaXQgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGZpZWxkIG5hbWVzLCB0aGVuIHRoZXJlIGFyZSBubyBkaWZmZXJlbmNlcy5cbiAgICAgKiBPdGhlcndpc2UsIHdlIGdldCB0aGUgZmlyc3Qgc2NoZW1hIGFuZCB0aGUgcmVtYWluaW5nIGxpc3Qgb2Ygc2NoZW1hc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZW1hRGlmZmVyZW5jZXMoZG9jdW1lbnRTY2hlbWFzKSB7XG4gICAgICAgIC8vIGhhdmUgbXVsdGlwbGUgZG9jdW1lbnRzIC0gZW5zdXJlIG9ubHkgb25lIHNjaGVtYSAocmVnYXJkbGVzcyBvZiBmaWVsZCBvcmRlcmluZylcbiAgICAgICAgY29uc3QgZmlyc3REb2NTY2hlbWEgPSBkb2N1bWVudFNjaGVtYXNbMF0sIHJlc3RPZkRvY3VtZW50U2NoZW1hcyA9IGRvY3VtZW50U2NoZW1hcy5zbGljZSgxKSwgc2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlTnVtYmVyT2ZTY2hlbWFEaWZmZXJlbmNlcyhmaXJzdERvY1NjaGVtYSwgcmVzdE9mRG9jdW1lbnRTY2hlbWFzKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNjaGVtYSBpbmNvbnNpc3RlbmNpZXMsIHRocm93IGEgc2NoZW1hIG5vdCB0aGUgc2FtZSBlcnJvclxuICAgICAgICBpZiAoc2NoZW1hRGlmZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb25zdGFudHNfMS5lcnJvcnMuanNvbjJjc3Yubm90U2FtZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0RG9jU2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIHNjaGVtYSBkaWZmZXJlbmNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVOdW1iZXJPZlNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCByZXN0T2ZEb2N1bWVudFNjaGVtYXMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RPZkRvY3VtZW50U2NoZW1hcy5yZWR1Y2UoKHNjaGVtYURpZmZlcmVuY2VzLCBkb2N1bWVudFNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNjaGVtYXMsIGluY3JlbWVudCB0aGUgY291bnRlciBvZiBzY2hlbWEgaW5jb25zaXN0ZW5jaWVzXG4gICAgICAgICAgICBjb25zdCBudW1iZXJPZkRpZmZlcmVuY2VzID0gdXRpbHMuY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzKGZpcnN0RG9jU2NoZW1hLCBkb2N1bWVudFNjaGVtYSkubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlck9mRGlmZmVyZW5jZXMgPiAwXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFEaWZmZXJlbmNlcyArIDFcbiAgICAgICAgICAgICAgICA6IHNjaGVtYURpZmZlcmVuY2VzO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc28gc3BlY2lmaWVkLCB0aGlzIGZpbHRlcnMgdGhlIGRldGVjdGVkIGtleSBwYXRocyB0byBleGNsdWRlIGFueSBrZXlzIHRoYXQgaGF2ZSBiZWVuIHNwZWNpZmllZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlckV4Y2x1ZGVkS2V5cyhrZXlQYXRocykge1xuICAgICAgICBpZiAob3B0aW9ucy5leGNsdWRlS2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIGtleVBhdGhzLmZpbHRlcigoa2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjbHVkZWRLZXkgb2Ygb3B0aW9ucy5leGNsdWRlS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG1hdGNoIGlmIHRoZSBleGNsdWRlZEtleSBhcHBlYXJzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgbWF0Y2ggYSBrZXkgZmFydGhlciBkb3duIGluIGEga2V5IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleGNsdWRlZEtleSBpbnN0YW5jZW9mIFJlZ0V4cCA/IGV4Y2x1ZGVkS2V5IDogbmV3IFJlZ0V4cChgXiR7ZXhjbHVkZWRLZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZEtleSA9PT0ga2V5UGF0aCB8fCBrZXlQYXRoLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFeGNsdWRlIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gT3RoZXJ3aXNlLCBpbmNsdWRlIHRoZSBrZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlQYXRocztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc28gc3BlY2lmaWVkLCB0aGlzIHNvcnRzIHRoZSBoZWFkZXIgZmllbGQgbmFtZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0SGVhZGVyRmllbGRzKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc29ydEhlYWRlciAmJiB0eXBlb2Ygb3B0aW9ucy5zb3J0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lcy5zb3J0KG9wdGlvbnMuc29ydEhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zb3J0SGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lcy5zb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSBoZWFkZXIgZmllbGRzLCBpZiB0aGUgdXNlciBkZXNpcmVzIHRoZW0gdG8gYmUgdHJpbW1lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltSGVhZGVyRmllbGRzKHBhcmFtcykge1xuICAgICAgICBpZiAob3B0aW9ucy50cmltSGVhZGVyRmllbGRzKSB7XG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzID0gcGFyYW1zLmhlYWRlckZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5zcGxpdCgnLicpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiBjb21wb25lbnQudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXAgdGhlIGhlYWRpbmdzLCBpZiBkZXNpcmVkIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBIZWFkZXJGaWVsZHMocGFyYW1zKSB7XG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSB0aGlzIGlmIHdlIGFyZSBhY3R1YWxseSBwcmVwZW5kaW5nIHRoZSBoZWFkZXJcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlcGVuZEhlYWRlcikge1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IHBhcmFtcy5oZWFkZXJGaWVsZHMubWFwKGZ1bmN0aW9uIChoZWFkaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBGaWVsZFZhbHVlSWZOZWNlc3NhcnkoaGVhZGluZ0tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIENTViBoZWFkZXIgc3RyaW5nIGJ5IGpvaW5pbmcgdGhlIGhlYWRlckZpZWxkcyBieSB0aGUgZmllbGQgZGVsaW1pdGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZIZWFkZXIocGFyYW1zKSB7XG4gICAgICAgIC8vICMxODUgLSBnZW5lcmF0ZSBhIGtleXMgbGlzdCB0byBhdm9pZCBmaW5kaW5nIG5hdGl2ZSBNYXAoKSBtZXRob2RzXG4gICAgICAgIGNvbnN0IGZpZWxkVGl0bGVNYXBLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5maWVsZFRpdGxlTWFwKTtcbiAgICAgICAgcGFyYW1zLmhlYWRlciA9IHBhcmFtcy5oZWFkZXJGaWVsZHNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyS2V5ID0gZmllbGQ7XG4gICAgICAgICAgICAvLyBJZiBhIGN1c3RvbSBmaWVsZCB0aXRsZSB3YXMgcHJvdmlkZWQgZm9yIHRoaXMgZmllbGQsIHVzZSB0aGF0XG4gICAgICAgICAgICBpZiAoZmllbGRUaXRsZU1hcEtleXMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyS2V5ID0gb3B0aW9ucy5maWVsZFRpdGxlTWFwW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmVzY2FwZUhlYWRlck5lc3RlZERvdHMpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSB1c2VyIGRvZXNuJ3Qgd2FudCBuZXN0ZWQgZG90cyBpbiBrZXlzIHRvIGJlIGVzY2FwZWQsIHRoZW4gdW5lc2NhcGUgdGhlbVxuICAgICAgICAgICAgICAgIGhlYWRlcktleSA9IGhlYWRlcktleS5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyS2V5O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0S2V5c1RvSGVhZGVyRmllbGRzKCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMua2V5cylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmICdmaWVsZCcgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZFRpdGxlTWFwW2tleS5maWVsZF0gPSBrZXkudGl0bGUgPz8ga2V5LmZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdFdpbGRjYXJkTWF0Y2hLZXlzKCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMua2V5cylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5cy5mbGF0TWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgcGxhaW4gc3RyaW5ncyB0aGF0IHdlcmUgcGFzc2VkIGluIG9wdGlvbnMua2V5c1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0/LndpbGRjYXJkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gXCJmaWVsZFwiIHZhbHVlIGZvciBvYmplY3RzIHdpdGggd2lsZGNhcmRNYXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhjbHVkZSBvdGhlciBvYmplY3RzXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgaGVhZGluZ3MgZm9yIGFsbCBkb2N1bWVudHMgYW5kIHJldHVybiBpdC5cbiAgICAgKiBUaGlzIGNoZWNrcyB0aGF0IGFsbCBkb2N1bWVudHMgaGF2ZSB0aGUgc2FtZSBzY2hlbWEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmVIZWFkZXJGaWVsZHMoZGF0YSkge1xuICAgICAgICBjb25zdCB3aWxkY2FyZE1hdGNoS2V5cyA9IGV4dHJhY3RXaWxkY2FyZE1hdGNoS2V5cygpO1xuICAgICAgICBjb25zdCBrZXlTdHJpbmdzID0gY29udmVydEtleXNUb0hlYWRlckZpZWxkcygpO1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gZ2V0RmllbGROYW1lTGlzdChkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gcHJvY2Vzc1NjaGVtYXMoZmllbGROYW1lcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmtleXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMua2V5cyA9IGtleVN0cmluZ3M7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkS2V5cyA9IGtleVN0cmluZ3MuZmxhdE1hcCgodXNlclByb3ZpZGVkS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSB3aWxkY2FyZCBtYXRjaGVkIGtleSwgdGhlbiBqdXN0IHJldHVybiBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVzdWx0aW5nIGtleSBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKCF3aWxkY2FyZE1hdGNoS2V5cy5pbmNsdWRlcyh1c2VyUHJvdmlkZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyUHJvdmlkZWRLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWRlbnRpZnkgYWxsIGRldGVjdGVkIGtleXMgdGhhdCBtYXRjaCB3aXRoIHRoZSBwcm92aWRlZCB3aWxkY2FyZCBrZXk6XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7dXNlclByb3ZpZGVkS2V5fWApO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGV0ZWN0ZWRLZXkgb2YgcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUHJvdmlkZWRLZXkgPT09IGRldGVjdGVkS2V5IHx8IGRldGVjdGVkS2V5Lm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGRldGVjdGVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVud2luZEFycmF5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gZmlsdGVyRXhjbHVkZWRLZXlzKG1hdGNoZWRLZXlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydEhlYWRlckZpZWxkcyhmaWx0ZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJFeGNsdWRlZEtleXMocHJvY2Vzc2VkKTtcbiAgICAgICAgcmV0dXJuIHNvcnRIZWFkZXJGaWVsZHMoZmlsdGVyZWQpO1xuICAgIH1cbiAgICAvKiogUkVDT1JEIEZJRUxEIEZVTkNUSU9OUyAqKi9cbiAgICAvKipcbiAgICAgKiBVbndpbmRzIG9iamVjdHMgaW4gYXJyYXlzIHdpdGhpbiByZWNvcmQgb2JqZWN0cyBpZiB0aGUgdXNlciBzcGVjaWZpZXMgdGhlXG4gICAgICogZXhwYW5kQXJyYXlPYmplY3RzIG9wdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhpcyBwYXNzZXMgdGhlIHBhcmFtc1xuICAgICAqIGFyZ3VtZW50IHRocm91Z2ggdG8gdGhlIG5leHQgZnVuY3Rpb24gaW4gdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICpcbiAgICAgKiBUaGUgYGZpbmFsUGFzc2AgcGFyYW1ldGVyIGlzIHVzZWQgdG8gdHJpZ2dlciBvbmUgbGFzdCBwYXNzIHRvIGVuc3VyZSBubyBtb3JlXG4gICAgICogYXJyYXlzIG5lZWQgdG8gYmUgZXhwYW5kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkocGFyYW1zLCBmaW5hbFBhc3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAob3B0aW9ucy51bndpbmRBcnJheXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUmVjb3Jkc0xlbmd0aCA9IHBhcmFtcy5yZWNvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIFVud2luZCBlYWNoIG9mIHRoZSBkb2N1bWVudHMgYXQgdGhlIGdpdmVuIGhlYWRlckZpZWxkXG4gICAgICAgICAgICBwYXJhbXMuaGVhZGVyRmllbGRzLmZvckVhY2goKGhlYWRlckZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlY29yZHMgPSB1dGlscy51bndpbmQocGFyYW1zLnJlY29yZHMsIGhlYWRlckZpZWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyRmllbGRzID0gcmV0cmlldmVIZWFkZXJGaWVsZHMocGFyYW1zLnJlY29yZHMpO1xuICAgICAgICAgICAgcGFyYW1zLmhlYWRlckZpZWxkcyA9IGhlYWRlckZpZWxkcztcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgYWJsZSB0byB1bndpbmQgbW9yZSBhcnJheXMsIHRoZW4gdHJ5IHVud2luZGluZyBhZ2Fpbi4uLlxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVjb3Jkc0xlbmd0aCAhPT0gcGFyYW1zLnJlY29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVud2luZFJlY29yZHNJZk5lY2Vzc2FyeShwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkaWRuJ3QgdW53aW5kIGFueSBhZGRpdGlvbmFsIGFycmF5cywgc28gY29udGludWUuLi5cbiAgICAgICAgICAgIC8vIFJ1biBhIGZpbmFsIHRpbWUgaW4gY2FzZSB0aGUgZWFybGllciB1bndpbmRpbmcgZXhwb3NlZCBhZGRpdGlvbmFsXG4gICAgICAgICAgICAvLyBhcnJheXMgdG8gdW53aW5kLi4uXG4gICAgICAgICAgICBpZiAoIWZpbmFsUGFzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bndpbmRSZWNvcmRzSWZOZWNlc3NhcnkocGFyYW1zLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgc2V0IHRoZSBoZWFkZXJGaWVsZHMgYmFjayB0byB0aGUgcHJvdmlkZWQga2V5cyBhZnRlciB1bndpbmRpbmc6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclNlbGVjdGVkRmllbGRzID0gY29udmVydEtleXNUb0hlYWRlckZpZWxkcygpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5oZWFkZXJGaWVsZHMgPSBmaWx0ZXJFeGNsdWRlZEtleXModXNlclNlbGVjdGVkRmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIHRoZSBwcm9jZXNzaW5nIG9mIGEgcmVjb3JkLCBvciBkb2N1bWVudCB0byBiZSBjb252ZXJ0ZWQgdG8gQ1NWIGZvcm1hdFxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3BlY2lmaWVzIGFuZCBwZXJmb3JtcyB0aGUgbmVjZXNzYXJ5IG9wZXJhdGlvbnMgaW4gdGhlIG5lY2Vzc2FyeSBvcmRlclxuICAgICAqIGluIG9yZGVyIHRvIG9idGFpbiB0aGUgZGF0YSBhbmQgY29udmVydCBpdCB0byBDU1YgZm9ybSB3aGlsZSBtYWludGFpbmluZyBSRkMgNDE4MCBjb21wbGlhbmNlLlxuICAgICAqICogT3JkZXIgb2Ygb3BlcmF0aW9uczpcbiAgICAgKiAtIEdldCBmaWVsZHMgZnJvbSBwcm92aWRlZCBrZXkgbGlzdCAoYXMgYXJyYXkgb2YgYWN0dWFsIHZhbHVlcylcbiAgICAgKiAtIENvbnZlcnQgdGhlIHZhbHVlcyB0byBjc3Yvc3RyaW5nIHJlcHJlc2VudGF0aW9uIFtwb3NzaWJsZSBvcHRpb24gaGVyZSBmb3IgY3VzdG9tIGNvbnZlcnRlcnM/XVxuICAgICAqIC0gVHJpbSBmaWVsZHNcbiAgICAgKiAtIERldGVybWluZSBpZiB0aGV5IG5lZWQgdG8gYmUgd3JhcHBlZCAoJiB3cmFwIGlmIG5lY2Vzc2FyeSlcbiAgICAgKiAtIENvbWJpbmUgdmFsdWVzIGZvciBlYWNoIGxpbmUgKGJ5IGpvaW5pbmcgYnkgZmllbGQgZGVsaW1pdGVyKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRzKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMucmVjb3JkU3RyaW5nID0gcGFyYW1zLnJlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGRhdGEgZm9yIGVhY2ggb2YgdGhlIGhlYWRlckZpZWxkcyBmcm9tIHRoaXMgcmVjb3JkXG4gICAgICAgICAgICBjb25zdCByZWNvcmRGaWVsZERhdGEgPSByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIHBhcmFtcy5oZWFkZXJGaWVsZHMpLCBcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGEgaW4gdGhpcyByZWNvcmQgYW5kIHJldHVybiB0aGVcbiAgICAgICAgICAgIHByb2Nlc3NlZFJlY29yZERhdGEgPSByZWNvcmRGaWVsZERhdGEubWFwKChmaWVsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IHRyaW1SZWNvcmRGaWVsZFZhbHVlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwcmV2ZW50Q3N2SW5qZWN0aW9uKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBzdHJpbmdpZmllZCA9IGN1c3RvbVZhbHVlUGFyc2VyID8gY3VzdG9tVmFsdWVQYXJzZXIoZmllbGRWYWx1ZSwgcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKSA6IHJlY29yZEZpZWxkVmFsdWVUb1N0cmluZyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZmllZCA9IHdyYXBGaWVsZFZhbHVlSWZOZWNlc3Nhcnkoc3RyaW5naWZpZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZmllZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSm9pbiB0aGUgcmVjb3JkIGRhdGEgYnkgdGhlIGZpZWxkIGRlbGltaXRlclxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ3N2Um93RnJvbVJlY29yZChwcm9jZXNzZWRSZWNvcmREYXRhKTtcbiAgICAgICAgfSkuam9pbihvcHRpb25zLmRlbGltaXRlci5lb2wpO1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gaW50ZW5kZWQgdG8gcHJvY2VzcyAqanVzdCogYXJyYXkgdmFsdWVzIHdoZW4gdGhlIGV4cGFuZEFycmF5T2JqZWN0cyBzZXR0aW5nIGlzIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1JlY29yZEZpZWxkRGF0YUZvckV4cGFuZGVkQXJyYXlPYmplY3QocmVjb3JkRmllbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUgPSB1dGlscy5yZW1vdmVFbXB0eUZpZWxkcyhyZWNvcmRGaWVsZFZhbHVlKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhcnJheSBhbmQgaXQncyBlaXRoZXIgZW1wdHkgb2YgZnVsbCBvZiBlbXB0eSB2YWx1ZXMsIHRoZW4gdXNlIGFuIGVtcHR5IHZhbHVlIHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGlmICghcmVjb3JkRmllbGRWYWx1ZS5sZW5ndGggfHwgIWZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVtcHR5RmllbGRWYWx1ZSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJlZFJlY29yZEZpZWxkVmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGhhdmUgYW4gYXJyYXkgb2YgYWN0dWFsIHZhbHVlcy4uLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYXJlIGV4cGFuZGluZyBhcnJheSBvYmplY3RzLCB3ZSB3aWxsIHdhbnQgdG8ga2V5IGluIG9uIHZhbHVlcyBvZiBvYmplY3RzLlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVjb3JkRmllbGRWYWx1ZVswXTsgLy8gRXh0cmFjdCB0aGUgc2luZ2xlIHZhbHVlIGluIHRoZSBhcnJheVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRGaWVsZFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBmaWVsZCB2YWx1ZXMgZnJvbSBhIHBhcnRpY3VsYXIgcmVjb3JkIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBmaWVsZHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVJlY29yZEZpZWxkRGF0YShyZWNvcmQsIGZpZWxkcykge1xuICAgICAgICBjb25zdCByZWNvcmRWYWx1ZXMgPSBbXTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjb3JkRmllbGRWYWx1ZSA9ICgwLCBkb2NfcGF0aF8xLmV2YWx1YXRlUGF0aCkocmVjb3JkLCBmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKG9wdGlvbnMuZW1wdHlGaWVsZFZhbHVlKSAmJiB1dGlscy5pc0VtcHR5RmllbGQocmVjb3JkRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmRGaWVsZFZhbHVlID0gb3B0aW9ucy5lbXB0eUZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmV4cGFuZEFycmF5T2JqZWN0cyAmJiBBcnJheS5pc0FycmF5KHJlY29yZEZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkRmllbGRWYWx1ZSA9IHByb2Nlc3NSZWNvcmRGaWVsZERhdGFGb3JFeHBhbmRlZEFycmF5T2JqZWN0KHJlY29yZEZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkVmFsdWVzLnB1c2gocmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVjb3JkVmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHJlY29yZCBmaWVsZCB2YWx1ZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3JkRmllbGRWYWx1ZVRvU3RyaW5nKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXNEYXRlID0gZmllbGRWYWx1ZSBpbnN0YW5jZW9mIERhdGU7IC8vIHN0b3JlIHRvIGF2b2lkIGNoZWNraW5nIHR3aWNlXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkgfHwgdHlwZW9mIGZpZWxkVmFsdWUgPT09ICdvYmplY3QnICYmICFpc0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShmaWVsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGUgJiYgb3B0aW9ucy51c2VEYXRlSXNvODYwMUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhb3B0aW9ucy51c2VMb2NhbGVGb3JtYXQgPyBmaWVsZFZhbHVlLnRvU3RyaW5nKCkgOiBmaWVsZFZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIHJlY29yZCBmaWVsZCB2YWx1ZSwgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyJ3MgcHJvdmlkZWQgb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SZWNvcmRGaWVsZFZhbHVlKGZpZWxkVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudHJpbUZpZWxkVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLm1hcCh0cmltUmVjb3JkRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudCBDU1YgaW5qZWN0aW9uIG9uIHN0cmluZ3MgaWYgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyJ3MgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiBNaXRpZ2F0aW9uIHdpbGwgYmUgZG9uZSBieSBlbnN1cmluZyB0aGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgZG9lc24ndCBiZWluZyB3aXRoOlxuICAgICAqIEVxdWFscyAoPSksIFBsdXMgKCspLCBNaW51cyAoLSksIEF0IChAKSwgVGFiICgweDA5KSwgQ2FycmlhZ2UgcmV0dXJuICgweDBEKS5cbiAgICAgKiBNb3JlIGluZm86IGh0dHBzOi8vb3dhc3Aub3JnL3d3dy1jb21tdW5pdHkvYXR0YWNrcy9DU1ZfSW5qZWN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJldmVudENzdkluamVjdGlvbihmaWVsZFZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnByZXZlbnRDc3ZJbmplY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUubWFwKHByZXZlbnRDc3ZJbmplY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpZWxkVmFsdWUgPT09ICdzdHJpbmcnICYmICF1dGlscy5pc051bWJlcihmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLnJlcGxhY2UoL15bPStcXC1AXFx0XFxyXSsvZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgcXVvdGF0aW9uIG1hcmtzIGluIHRoZSBmaWVsZCB2YWx1ZSwgaWYgbmVjZXNzYXJ5LCBhbmQgYXBwcm9wcmlhdGVseVxuICAgICAqIHdyYXBzIHRoZSByZWNvcmQgZmllbGQgdmFsdWUgaWYgaXQgY29udGFpbnMgYSBjb21tYSAoZmllbGQgZGVsaW1pdGVyKSxcbiAgICAgKiBxdW90YXRpb24gbWFyayAod3JhcCBkZWxpbWl0ZXIpLCBvciBhIGxpbmUgYnJlYWsgKENSTEYpXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcEZpZWxkVmFsdWVJZk5lY2Vzc2FyeShmaWVsZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHdyYXBEZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci53cmFwO1xuICAgICAgICAvLyBlZy4gaW5jbHVkZXMgcXVvdGF0aW9uIG1hcmtzIChkZWZhdWx0IGRlbGltaXRlcilcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBhZGRpdGlvbmFsIHF1b3RhdGlvbiBtYXJrIGJlZm9yZSBlYWNoIHF1b3RhdGlvbiBtYXJrIGFwcGVhcmluZyBpbiB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBmaWVsZFZhbHVlLnJlcGxhY2Uod3JhcERlbGltaXRlckNoZWNrUmVnZXgsIHdyYXBEZWxpbWl0ZXIgKyB3cmFwRGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgZmllbGQgY29udGFpbnMgYSBjb21tYSAoZmllbGQgZGVsaW1pdGVyKSwgcXVvdGF0aW9uIG1hcmsgKHdyYXAgZGVsaW1pdGVyKSwgbGluZSBicmVhaywgb3IgQ1JMRlxuICAgICAgICAvLyAgIHRoZW4gZW5jbG9zZSBpdCBpbiBxdW90YXRpb24gbWFya3MgKHdyYXAgZGVsaW1pdGVyKVxuICAgICAgICBpZiAoZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25zLmRlbGltaXRlci5maWVsZCkgfHxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9ucy5kZWxpbWl0ZXIud3JhcCkgfHxcbiAgICAgICAgICAgIGZpZWxkVmFsdWUubWF0Y2goY3JsZlNlYXJjaFJlZ2V4KSB8fFxuICAgICAgICAgICAgb3B0aW9ucy53cmFwQm9vbGVhbnMgJiYgKGZpZWxkVmFsdWUgPT09ICd0cnVlJyB8fCBmaWVsZFZhbHVlID09PSAnZmFsc2UnKSkge1xuICAgICAgICAgICAgLy8gd3JhcCB0aGUgZmllbGQncyB2YWx1ZSBpbiBhIHdyYXAgZGVsaW1pdGVyIChxdW90YXRpb24gbWFya3MgYnkgZGVmYXVsdClcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB3cmFwRGVsaW1pdGVyICsgZmllbGRWYWx1ZSArIHdyYXBEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgQ1NWIHJlY29yZCBzdHJpbmcgYnkgam9pbmluZyB0aGUgZmllbGQgdmFsdWVzIHRvZ2V0aGVyIGJ5IHRoZSBmaWVsZCBkZWxpbWl0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNzdlJvd0Zyb21SZWNvcmQocmVjb3JkRmllbGRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZEZpZWxkVmFsdWVzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIuZmllbGQpO1xuICAgIH1cbiAgICAvKiogQ1NWIENPTVBPTkVOVCBDT01CSU5FUi9GSU5BTCBQUk9DRVNTT1IgKiovXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIGZpbmFsIENTViBjb25zdHJ1Y3Rpb24gYnkgY29tYmluaW5nIHRoZSBmaWVsZHMgaW4gdGhlIGFwcHJvcHJpYXRlXG4gICAgICogb3JkZXIgZGVwZW5kaW5nIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zIHZhbHVlcyBhbmQgc2VuZHMgdGhlIGdlbmVyYXRlZCBDU1ZcbiAgICAgKiBiYWNrIHRvIHRoZSB1c2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDc3ZGcm9tQ29tcG9uZW50cyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gcGFyYW1zLmhlYWRlciwgcmVjb3JkcyA9IHBhcmFtcy5yZWNvcmRTdHJpbmcsIFxuICAgICAgICAvLyBJZiB3ZSBhcmUgcHJlcGVuZGluZyB0aGUgaGVhZGVyLCB0aGVuIGFkZCBhbiBFT0wsIG90aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgcmVjb3Jkc1xuICAgICAgICBjc3YgPSAob3B0aW9ucy5leGNlbEJPTSA/IGNvbnN0YW50c18xLmV4Y2VsQk9NIDogJycpICtcbiAgICAgICAgICAgIChvcHRpb25zLnByZXBlbmRIZWFkZXIgPyBoZWFkZXIgKyBvcHRpb25zLmRlbGltaXRlci5lb2wgOiAnJykgK1xuICAgICAgICAgICAgcmVjb3JkcztcbiAgICAgICAgcmV0dXJuIGNzdjtcbiAgICB9XG4gICAgLyoqIE1BSU4gQ09OVkVSVEVSIEZVTkNUSU9OICoqL1xuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgZXhwb3J0ZWQganNvbjJjc3YgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0KGRhdGEpIHtcbiAgICAgICAgLy8gU2luZ2xlIGRvY3VtZW50LCBub3QgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gW2RhdGFdOyAvLyBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBoZWFkaW5nIGFuZCB0aGVuIGdlbmVyYXRlIHRoZSBDU1Ygd2l0aCB0aGUga2V5cyB0aGF0IGFyZSBpZGVudGlmaWVkXG4gICAgICAgIGNvbnN0IGhlYWRlckZpZWxkcyA9IHtcbiAgICAgICAgICAgIGhlYWRlckZpZWxkczogcmV0cmlldmVIZWFkZXJGaWVsZHMoZGF0YSksXG4gICAgICAgICAgICByZWNvcmRzOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiAnJyxcbiAgICAgICAgICAgIHJlY29yZFN0cmluZzogJycsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVud2luZGVkID0gdW53aW5kUmVjb3Jkc0lmTmVjZXNzYXJ5KGhlYWRlckZpZWxkcyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IHByb2Nlc3NSZWNvcmRzKHVud2luZGVkKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHdyYXBIZWFkZXJGaWVsZHMocHJvY2Vzc2VkKTtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHRyaW1IZWFkZXJGaWVsZHMod3JhcHBlZCk7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGdlbmVyYXRlQ3N2SGVhZGVyKHRyaW1tZWQpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVDc3ZGcm9tQ29tcG9uZW50cyhnZW5lcmF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb252ZXJ0LFxuICAgIH07XG59O1xuZXhwb3J0cy5Kc29uMkNzdiA9IEpzb24yQ3N2O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/json2csv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/json-2-csv/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/json-2-csv/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;\nconst doc_path_1 = __webpack_require__(/*! doc-path */ \"(ssr)/./node_modules/doc-path/lib/path.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/json-2-csv/lib/constants.js\");\nconst dateStringRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/, MAX_ARRAY_LENGTH = 100000;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildJ2COptions(opts) {\n    return {\n        ...constants_1.defaultJson2CsvOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultJson2CsvOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultJson2CsvOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultJson2CsvOptions.delimiter.eol,\n        },\n        fieldTitleMap: Object.create({}),\n    };\n}\nexports.buildJ2COptions = buildJ2COptions;\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nfunction buildC2JOptions(opts) {\n    return {\n        ...constants_1.defaultCsv2JsonOptions,\n        ...opts,\n        delimiter: {\n            field: opts?.delimiter?.field ?? constants_1.defaultCsv2JsonOptions.delimiter.field,\n            wrap: opts?.delimiter?.wrap || constants_1.defaultCsv2JsonOptions.delimiter.wrap,\n            eol: opts?.delimiter?.eol || constants_1.defaultCsv2JsonOptions.delimiter.eol,\n        },\n    };\n}\nexports.buildC2JOptions = buildC2JOptions;\nfunction validate(data, validationFn, errorMessages) {\n    if (!data)\n        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);\n    if (!validationFn(data))\n        throw new Error(errorMessages.dataCheckFailure);\n    return true;\n}\nexports.validate = validate;\n/**\n * Utility function to deep copy an object, used by the module tests\n */\nfunction deepCopy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.deepCopy = deepCopy;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a string. Given the RFC4180 requirements, that means that the value is\n *   wrapped in value wrap delimiters (usually a quotation mark on each side).\n */\nfunction isStringRepresentation(fieldValue, options) {\n    const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];\n    // If the field starts and ends with a wrap delimiter\n    return firstChar === options.delimiter.wrap && lastChar === options.delimiter.wrap;\n}\nexports.isStringRepresentation = isStringRepresentation;\n/**\n * Helper function that determines whether the provided value is a representation\n *   of a date.\n */\nfunction isDateRepresentation(fieldValue) {\n    return dateStringRegex.test(fieldValue);\n}\nexports.isDateRepresentation = isDateRepresentation;\n/**\n * Helper function that determines the schema differences between two objects.\n */\nfunction computeSchemaDifferences(schemaA, schemaB) {\n    return arrayDifference(schemaA, schemaB)\n        .concat(arrayDifference(schemaB, schemaA));\n}\nexports.computeSchemaDifferences = computeSchemaDifferences;\n/**\n * Utility function to check if a field is considered empty so that the emptyFieldValue can be used instead\n */\nfunction isEmptyField(fieldValue) {\n    return isUndefined(fieldValue) || isNull(fieldValue) || fieldValue === '';\n}\nexports.isEmptyField = isEmptyField;\n/**\n * Helper function that removes empty field values from an array.\n */\nfunction removeEmptyFields(fields) {\n    return fields.filter((field) => !isEmptyField(field));\n}\nexports.removeEmptyFields = removeEmptyFields;\n/**\n * Helper function that retrieves the next n characters from the start index in\n *   the string including the character at the start index. This is used to\n *   check if are currently at an EOL value, since it could be multiple\n *   characters in length (eg. '\\r\\n')\n */\nfunction getNCharacters(str, start, n) {\n    return str.substring(start, start + n);\n}\nexports.getNCharacters = getNCharacters;\n/**\n * The following unwind functionality is a heavily modified version of @edwincen's\n * unwind extension for lodash. Since lodash is a large package to require in,\n * and all of the required functionality was already being imported, either\n * natively or with doc-path, I decided to rewrite the majority of the logic\n * so that an additional dependency would not be required. The original code\n * with the lodash dependency can be found here:\n *\n * https://github.com/edwincen/unwind/blob/master/index.js\n */\n/**\n * Core function that unwinds an item at the provided path\n */\nfunction unwindItem(accumulator, item, fieldPath) {\n    const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);\n    let cloned = deepCopy(item);\n    if (Array.isArray(valueToUnwind) && valueToUnwind.length) {\n        valueToUnwind.forEach((val) => {\n            cloned = deepCopy(item);\n            accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));\n        });\n    }\n    else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {\n        // Push an empty string so the value is empty since there are no values\n        (0, doc_path_1.setPath)(cloned, fieldPath, '');\n        accumulator.push(cloned);\n    }\n    else {\n        accumulator.push(cloned);\n    }\n}\n/**\n * Main unwind function which takes an array and a field to unwind.\n */\nfunction unwind(array, field) {\n    const result = [];\n    array.forEach((item) => {\n        unwindItem(result, item, field);\n    });\n    return result;\n}\nexports.unwind = unwind;\n/**\n * Checks whether value can be converted to a number\n */\nfunction isNumber(value) {\n    return !isNaN(Number(value));\n}\nexports.isNumber = isNumber;\n/*\n * Helper functions which were created to remove underscorejs from this package.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\nfunction isObject(value) {\n    return typeof value === 'object';\n}\nexports.isObject = isObject;\nfunction isNull(value) {\n    return value === null;\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isError(value) {\n    // TODO(mrodrig): test this possible change\n    // return value instanceof Error;\n    return Object.prototype.toString.call(value) === '[object Error]';\n}\nexports.isError = isError;\nfunction arrayDifference(a, b) {\n    return a.filter((x) => !b.includes(x));\n}\nexports.arrayDifference = arrayDifference;\nfunction unique(array) {\n    return [...new Set(array)];\n}\nexports.unique = unique;\nfunction flatten(array) {\n    // Node 11+ - use the native array flattening function\n    if (array.flat) {\n        return array.flat();\n    }\n    // #167 - allow browsers to flatten very long 200k+ element arrays\n    if (array.length > MAX_ARRAY_LENGTH) {\n        let safeArray = [];\n        for (let a = 0; a < array.length; a += MAX_ARRAY_LENGTH) {\n            safeArray = safeArray.concat(...array.slice(a, a + MAX_ARRAY_LENGTH));\n        }\n        return safeArray;\n    }\n    return array.reduce((accumulator, value) => accumulator.concat(value), []);\n}\nexports.flatten = flatten;\n/**\n * Used to help avoid incorrect values returned by JSON.parse when converting\n * CSV back to JSON, such as '39e1804' which JSON.parse converts to Infinity\n */\nfunction isInvalid(parsedJson) {\n    return parsedJson === Infinity ||\n        parsedJson === -Infinity;\n}\nexports.isInvalid = isInvalid;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbi0yLWNzdi9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDMWQsbUJBQW1CLG1CQUFPLENBQUMsMkRBQVU7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUVBQWE7QUFDekMsNEJBQTRCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QixFQUFFLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2l0ZS8uL25vZGVfbW9kdWxlcy9qc29uLTItY3N2L2xpYi91dGlscy5qcz8yMWNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNJbnZhbGlkID0gZXhwb3J0cy5mbGF0dGVuID0gZXhwb3J0cy51bmlxdWUgPSBleHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGV4cG9ydHMuaXNFcnJvciA9IGV4cG9ydHMuaXNVbmRlZmluZWQgPSBleHBvcnRzLmlzTnVsbCA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc051bWJlciA9IGV4cG9ydHMudW53aW5kID0gZXhwb3J0cy5nZXROQ2hhcmFjdGVycyA9IGV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSBleHBvcnRzLmlzRW1wdHlGaWVsZCA9IGV4cG9ydHMuY29tcHV0ZVNjaGVtYURpZmZlcmVuY2VzID0gZXhwb3J0cy5pc0RhdGVSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGV4cG9ydHMuZGVlcENvcHkgPSBleHBvcnRzLnZhbGlkYXRlID0gZXhwb3J0cy5idWlsZEMySk9wdGlvbnMgPSBleHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGRvY19wYXRoXzEgPSByZXF1aXJlKFwiZG9jLXBhdGhcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRhdGVTdHJpbmdSZWdleCA9IC9cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfS5cXGR7M31aLywgTUFYX0FSUkFZX0xFTkdUSCA9IDEwMDAwMDtcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSjJDT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdEpzb24yQ3N2T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0SnNvbjJDc3ZPcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkVGl0bGVNYXA6IE9iamVjdC5jcmVhdGUoe30pLFxuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkSjJDT3B0aW9ucyA9IGJ1aWxkSjJDT3B0aW9ucztcbi8qKlxuICogQnVpbGQgdGhlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBmdW5jdGlvblxuICogSWYgYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgY3VzdG9tIG9wdGlvbnMsIHRoZW4gd2UgdXNlIG91ciBkZWZhdWx0XG4gKiBJZiBvcHRpb25zIGFyZSBwcm92aWRlZCwgdGhlbiB3ZSBzZXQgZWFjaCB2YWxpZCBrZXkgdGhhdCB3YXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQzJKT3B0aW9ucyhvcHRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uc3RhbnRzXzEuZGVmYXVsdENzdjJKc29uT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgZGVsaW1pdGVyOiB7XG4gICAgICAgICAgICBmaWVsZDogb3B0cz8uZGVsaW1pdGVyPy5maWVsZCA/PyBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5maWVsZCxcbiAgICAgICAgICAgIHdyYXA6IG9wdHM/LmRlbGltaXRlcj8ud3JhcCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci53cmFwLFxuICAgICAgICAgICAgZW9sOiBvcHRzPy5kZWxpbWl0ZXI/LmVvbCB8fCBjb25zdGFudHNfMS5kZWZhdWx0Q3N2Mkpzb25PcHRpb25zLmRlbGltaXRlci5lb2wsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuYnVpbGRDMkpPcHRpb25zID0gYnVpbGRDMkpPcHRpb25zO1xuZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSwgdmFsaWRhdGlvbkZuLCBlcnJvck1lc3NhZ2VzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlcy5jYW5ub3RDYWxsT259ICR7ZGF0YX0uYCk7XG4gICAgaWYgKCF2YWxpZGF0aW9uRm4oZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzLmRhdGFDaGVja0ZhaWx1cmUpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRlZXAgY29weSBhbiBvYmplY3QsIHVzZWQgYnkgdGhlIG1vZHVsZSB0ZXN0c1xuICovXG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIHJlcHJlc2VudGF0aW9uXG4gKiAgIG9mIGEgc3RyaW5nLiBHaXZlbiB0aGUgUkZDNDE4MCByZXF1aXJlbWVudHMsIHRoYXQgbWVhbnMgdGhhdCB0aGUgdmFsdWUgaXNcbiAqICAgd3JhcHBlZCBpbiB2YWx1ZSB3cmFwIGRlbGltaXRlcnMgKHVzdWFsbHkgYSBxdW90YXRpb24gbWFyayBvbiBlYWNoIHNpZGUpLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ1JlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXJzdENoYXIgPSBmaWVsZFZhbHVlWzBdLCBsYXN0SW5kZXggPSBmaWVsZFZhbHVlLmxlbmd0aCAtIDEsIGxhc3RDaGFyID0gZmllbGRWYWx1ZVtsYXN0SW5kZXhdO1xuICAgIC8vIElmIHRoZSBmaWVsZCBzdGFydHMgYW5kIGVuZHMgd2l0aCBhIHdyYXAgZGVsaW1pdGVyXG4gICAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcCAmJiBsYXN0Q2hhciA9PT0gb3B0aW9ucy5kZWxpbWl0ZXIud3JhcDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdSZXByZXNlbnRhdGlvbiA9IGlzU3RyaW5nUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSByZXByZXNlbnRhdGlvblxuICogICBvZiBhIGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZVJlcHJlc2VudGF0aW9uKGZpZWxkVmFsdWUpIHtcbiAgICByZXR1cm4gZGF0ZVN0cmluZ1JlZ2V4LnRlc3QoZmllbGRWYWx1ZSk7XG59XG5leHBvcnRzLmlzRGF0ZVJlcHJlc2VudGF0aW9uID0gaXNEYXRlUmVwcmVzZW50YXRpb247XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIHNjaGVtYSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMoc2NoZW1hQSwgc2NoZW1hQikge1xuICAgIHJldHVybiBhcnJheURpZmZlcmVuY2Uoc2NoZW1hQSwgc2NoZW1hQilcbiAgICAgICAgLmNvbmNhdChhcnJheURpZmZlcmVuY2Uoc2NoZW1hQiwgc2NoZW1hQSkpO1xufVxuZXhwb3J0cy5jb21wdXRlU2NoZW1hRGlmZmVyZW5jZXMgPSBjb21wdXRlU2NoZW1hRGlmZmVyZW5jZXM7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBmaWVsZCBpcyBjb25zaWRlcmVkIGVtcHR5IHNvIHRoYXQgdGhlIGVtcHR5RmllbGRWYWx1ZSBjYW4gYmUgdXNlZCBpbnN0ZWFkXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlGaWVsZChmaWVsZFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkVmFsdWUpIHx8IGlzTnVsbChmaWVsZFZhbHVlKSB8fCBmaWVsZFZhbHVlID09PSAnJztcbn1cbmV4cG9ydHMuaXNFbXB0eUZpZWxkID0gaXNFbXB0eUZpZWxkO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZW1vdmVzIGVtcHR5IGZpZWxkIHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpZWxkcyhmaWVsZHMpIHtcbiAgICByZXR1cm4gZmllbGRzLmZpbHRlcigoZmllbGQpID0+ICFpc0VtcHR5RmllbGQoZmllbGQpKTtcbn1cbmV4cG9ydHMucmVtb3ZlRW1wdHlGaWVsZHMgPSByZW1vdmVFbXB0eUZpZWxkcztcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmVzIHRoZSBuZXh0IG4gY2hhcmFjdGVycyBmcm9tIHRoZSBzdGFydCBpbmRleCBpblxuICogICB0aGUgc3RyaW5nIGluY2x1ZGluZyB0aGUgY2hhcmFjdGVyIGF0IHRoZSBzdGFydCBpbmRleC4gVGhpcyBpcyB1c2VkIHRvXG4gKiAgIGNoZWNrIGlmIGFyZSBjdXJyZW50bHkgYXQgYW4gRU9MIHZhbHVlLCBzaW5jZSBpdCBjb3VsZCBiZSBtdWx0aXBsZVxuICogICBjaGFyYWN0ZXJzIGluIGxlbmd0aCAoZWcuICdcXHJcXG4nKVxuICovXG5mdW5jdGlvbiBnZXROQ2hhcmFjdGVycyhzdHIsIHN0YXJ0LCBuKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIHN0YXJ0ICsgbik7XG59XG5leHBvcnRzLmdldE5DaGFyYWN0ZXJzID0gZ2V0TkNoYXJhY3RlcnM7XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgdW53aW5kIGZ1bmN0aW9uYWxpdHkgaXMgYSBoZWF2aWx5IG1vZGlmaWVkIHZlcnNpb24gb2YgQGVkd2luY2VuJ3NcbiAqIHVud2luZCBleHRlbnNpb24gZm9yIGxvZGFzaC4gU2luY2UgbG9kYXNoIGlzIGEgbGFyZ2UgcGFja2FnZSB0byByZXF1aXJlIGluLFxuICogYW5kIGFsbCBvZiB0aGUgcmVxdWlyZWQgZnVuY3Rpb25hbGl0eSB3YXMgYWxyZWFkeSBiZWluZyBpbXBvcnRlZCwgZWl0aGVyXG4gKiBuYXRpdmVseSBvciB3aXRoIGRvYy1wYXRoLCBJIGRlY2lkZWQgdG8gcmV3cml0ZSB0aGUgbWFqb3JpdHkgb2YgdGhlIGxvZ2ljXG4gKiBzbyB0aGF0IGFuIGFkZGl0aW9uYWwgZGVwZW5kZW5jeSB3b3VsZCBub3QgYmUgcmVxdWlyZWQuIFRoZSBvcmlnaW5hbCBjb2RlXG4gKiB3aXRoIHRoZSBsb2Rhc2ggZGVwZW5kZW5jeSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWR3aW5jZW4vdW53aW5kL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKi9cbi8qKlxuICogQ29yZSBmdW5jdGlvbiB0aGF0IHVud2luZHMgYW4gaXRlbSBhdCB0aGUgcHJvdmlkZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bndpbmRJdGVtKGFjY3VtdWxhdG9yLCBpdGVtLCBmaWVsZFBhdGgpIHtcbiAgICBjb25zdCB2YWx1ZVRvVW53aW5kID0gKDAsIGRvY19wYXRoXzEuZXZhbHVhdGVQYXRoKShpdGVtLCBmaWVsZFBhdGgpO1xuICAgIGxldCBjbG9uZWQgPSBkZWVwQ29weShpdGVtKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvVW53aW5kKSAmJiB2YWx1ZVRvVW53aW5kLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZVRvVW53aW5kLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgY2xvbmVkID0gZGVlcENvcHkoaXRlbSk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKCgwLCBkb2NfcGF0aF8xLnNldFBhdGgpKGNsb25lZCwgZmllbGRQYXRoLCB2YWwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUb1Vud2luZCkgJiYgdmFsdWVUb1Vud2luZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUHVzaCBhbiBlbXB0eSBzdHJpbmcgc28gdGhlIHZhbHVlIGlzIGVtcHR5IHNpbmNlIHRoZXJlIGFyZSBubyB2YWx1ZXNcbiAgICAgICAgKDAsIGRvY19wYXRoXzEuc2V0UGF0aCkoY2xvbmVkLCBmaWVsZFBhdGgsICcnKTtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0b3IucHVzaChjbG9uZWQpO1xuICAgIH1cbn1cbi8qKlxuICogTWFpbiB1bndpbmQgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJyYXkgYW5kIGEgZmllbGQgdG8gdW53aW5kLlxuICovXG5mdW5jdGlvbiB1bndpbmQoYXJyYXksIGZpZWxkKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICB1bndpbmRJdGVtKHJlc3VsdCwgaXRlbSwgZmllbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVud2luZCA9IHVud2luZDtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdmFsdWUgY2FuIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlclxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyB3aGljaCB3ZXJlIGNyZWF0ZWQgdG8gcmVtb3ZlIHVuZGVyc2NvcmVqcyBmcm9tIHRoaXMgcGFja2FnZS5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgLy8gVE9ETyhtcm9kcmlnKTogdGVzdCB0aGlzIHBvc3NpYmxlIGNoYW5nZVxuICAgIC8vIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmZ1bmN0aW9uIGFycmF5RGlmZmVyZW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKCh4KSA9PiAhYi5pbmNsdWRlcyh4KSk7XG59XG5leHBvcnRzLmFycmF5RGlmZmVyZW5jZSA9IGFycmF5RGlmZmVyZW5jZTtcbmZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheSldO1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgLy8gTm9kZSAxMSsgLSB1c2UgdGhlIG5hdGl2ZSBhcnJheSBmbGF0dGVuaW5nIGZ1bmN0aW9uXG4gICAgaWYgKGFycmF5LmZsYXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmZsYXQoKTtcbiAgICB9XG4gICAgLy8gIzE2NyAtIGFsbG93IGJyb3dzZXJzIHRvIGZsYXR0ZW4gdmVyeSBsb25nIDIwMGsrIGVsZW1lbnQgYXJyYXlzXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgbGV0IHNhZmVBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGFycmF5Lmxlbmd0aDsgYSArPSBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICBzYWZlQXJyYXkgPSBzYWZlQXJyYXkuY29uY2F0KC4uLmFycmF5LnNsaWNlKGEsIGEgKyBNQVhfQVJSQVlfTEVOR1RIKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhZmVBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgoYWNjdW11bGF0b3IsIHZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQodmFsdWUpLCBbXSk7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuLyoqXG4gKiBVc2VkIHRvIGhlbHAgYXZvaWQgaW5jb3JyZWN0IHZhbHVlcyByZXR1cm5lZCBieSBKU09OLnBhcnNlIHdoZW4gY29udmVydGluZ1xuICogQ1NWIGJhY2sgdG8gSlNPTiwgc3VjaCBhcyAnMzllMTgwNCcgd2hpY2ggSlNPTi5wYXJzZSBjb252ZXJ0cyB0byBJbmZpbml0eVxuICovXG5mdW5jdGlvbiBpc0ludmFsaWQocGFyc2VkSnNvbikge1xuICAgIHJldHVybiBwYXJzZWRKc29uID09PSBJbmZpbml0eSB8fFxuICAgICAgICBwYXJzZWRKc29uID09PSAtSW5maW5pdHk7XG59XG5leHBvcnRzLmlzSW52YWxpZCA9IGlzSW52YWxpZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/json-2-csv/lib/utils.js\n");

/***/ })

};
;